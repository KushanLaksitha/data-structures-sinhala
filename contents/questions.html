
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COM 2307 - Data Structures and Algorithms | Exam Paper with Solutions</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Sinhala:wght@400;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            line-height: 1.6;
        }

        .sinhala-text {
            font-family: 'Noto Sans Sinhala', sans-serif;
        }

        .paper-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .paper-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .paper-header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .paper-header .university {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .paper-header .faculty {
            font-size: 1rem;
            opacity: 0.9;
        }

        .paper-info {
            background: #f8f9fa;
            padding: 20px 40px;
            border-bottom: 3px solid #667eea;
        }

        .paper-info p {
            margin: 5px 0;
            font-weight: 600;
            color: #333;
        }

        .instructions {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px 40px;
            margin: 0;
        }

        .instructions ul {
            margin: 10px 0 0 20px;
        }

        .content-area {
            padding: 40px;
        }

        .question-block {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .question-number {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 1.5rem;
            font-weight: 700;
            padding: 10px 20px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .sub-question {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .sub-question-label {
            font-weight: 700;
            color: #667eea;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .marks {
            float: right;
            background: #e3f2fd;
            color: #1976d2;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .answer-section {
            margin-top: 20px;
            border-top: 2px dashed #ddd;
            padding-top: 20px;
        }

        .answer-toggle {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px 5px;
        }

        .answer-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .answer-toggle.sinhala {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .answer-content {
            display: none;
            margin-top: 15px;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
        }

        .answer-content.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
        }

        .code-block pre {
            margin: 0;
            white-space: pre;
        }

        .keyword { color: #569cd6; }
        .function { color: #dcdcaa; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .number { color: #b5cea8; }
        .type { color: #4ec9b0; }

        .definition-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .example-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .comparison-table {
            width: 100%;
            margin: 15px 0;
            border-collapse: collapse;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .formula {
            background: #fff9c4;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Fira Code', monospace;
            font-weight: 600;
            display: inline-block;
            margin: 10px 0;
        }

        .lang-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .lang-btn {
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            margin: 0 5px;
            transition: all 0.3s;
        }

        .lang-btn.active {
            background: #667eea;
            color: white;
        }

        .lang-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        h3 {
            color: #667eea;
            font-weight: 700;
            margin: 20px 0 10px 0;
        }

        h4 {
            color: #764ba2;
            font-weight: 600;
            margin: 15px 0 8px 0;
        }

        .highlight {
            background: #fff59d;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        .note-box {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        ul, ol {
            margin-left: 20px;
        }

        li {
            margin: 8px 0;
        }

        @media print {
            .answer-toggle, .lang-switch {
                display: none;
            }
            .answer-content {
                display: block !important;
            }
        }
    </style>
</head>
<body>
    <div class="paper-container">
        <div class="paper-header">
            <h1 style="margin-top: 20px;">DATA STRUCTURES AND ALGORITHMS</h1>
        </div>

        <div class="paper-info">
            <p><strong>Time:</strong> Three (03) hours</p>
            <p><strong>Total Marks:</strong> 100</p>
        </div>

        <div class="instructions">
            <h4>INSTRUCTIONS:</h4>
            <ul>
                <li>Answer ALL questions.</li>
                <li>This paper consists of five (05) questions in multiple pages.</li>
                <li>Each question carries 20 marks.</li>
                <li>Use of calculators is permitted.</li>
            </ul>
        </div>

        <div class="content-area">
            <!-- QUESTION 1 -->
            <div class="question-block">
                <div class="question-number">Question 1</div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        a) Define Big O notation and explain its significance in algorithm analysis.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q1a-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q1a-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q1a-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <div class="definition-box">
                            <strong>Big O Notation Definition:</strong><br>
                            Big O notation is a mathematical notation used to describe the upper bound of an algorithm's time or space complexity in terms of the input size (n). It provides a worst-case scenario analysis.
                        </div>

                        <h4>Notation Format:</h4>
                        <p class="formula">f(n) = O(g(n))</p>
                        <p>This means f(n) grows at most as fast as g(n) for large values of n.</p>

                        <h4>Significance in Algorithm Analysis:</h4>
                        <ol>
                            <li><strong>Performance Prediction:</strong> Helps predict how an algorithm will perform as input size increases</li>
                            <li><strong>Algorithm Comparison:</strong> Allows comparison of different algorithms independent of hardware/software</li>
                            <li><strong>Scalability Assessment:</strong> Indicates how well an algorithm scales with larger datasets</li>
                            <li><strong>Resource Planning:</strong> Helps in estimating computational resources needed</li>
                        </ol>

                        <div class="example-box">
                            <strong>Common Big O Notations (Best to Worst):</strong>
                            <ul>
                                <li><strong>O(1)</strong> - Constant time (e.g., array access by index)</li>
                                <li><strong>O(log n)</strong> - Logarithmic time (e.g., binary search)</li>
                                <li><strong>O(n)</strong> - Linear time (e.g., linear search)</li>
                                <li><strong>O(n log n)</strong> - Linearithmic time (e.g., merge sort)</li>
                                <li><strong>O(n²)</strong> - Quadratic time (e.g., bubble sort)</li>
                                <li><strong>O(2ⁿ)</strong> - Exponential time (e.g., recursive fibonacci)</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q1a-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <div class="definition-box">
                            <strong>Big O සංකේතනය අර්ථ දැක්වීම:</strong><br>
                            Big O සංකේතනය යනු ඇල්ගොරිතමයක කාල හෝ අවකාශ සංකීර්ණත්වයේ ඉහළ සීමාව ආදාන ප්‍රමාණය (n) අනුව විස්තර කිරීමට භාවිතා කරන ගණිතමය සංකේතනයකි. එය නරකම අවස්ථාවේ විශ්ලේෂණයක් සපයයි.
                        </div>

                        <h4>ඇල්ගොරිතම විශ්ලේෂණයේ වැදගත්කම:</h4>
                        <ol>
                            <li><strong>ක්‍රියාකාරිත්ව අනාවැකිය:</strong> ආදාන ප්‍රමාණය වැඩි වන විට ඇල්ගොරිතමය ක්‍රියා කරන ආකාරය අනාවැකි කිරීමට උපකාරී වේ</li>
                            <li><strong>ඇල්ගොරිතම සංසන්දනය:</strong> දෘඪාංග/මෘදුකාංග නොසලකා විවිධ ඇල්ගොරිතම සංසන්දනය කිරීමට ඉඩ දෙයි</li>
                            <li><strong>පරිමාණ කිරීමේ හැකියාව:</strong> විශාල දත්ත කට්ටල සමඟ ඇල්ගොරිතමය කොතරම් හොඳින් පරිමාණය වේද යන්න පෙන්වයි</li>
                            <li><strong>සම්පත් සැලසුම්:</strong> අවශ්‍ය පරිගණක සම්පත් තක්සේරු කිරීමට උපකාරී වේ</li>
                        </ol>

                        <div class="example-box">
                            <strong>සාමාන්‍ය Big O සංකේත (හොඳම සිට නරකම):</strong>
                            <ul>
                                <li><strong>O(1)</strong> - නියත කාලය (උදා: දර්ශකය අනුව අරා ප්‍රවේශය)</li>
                                <li><strong>O(log n)</strong> - ලඝුගණක කාලය (උදා: ද්විමය සෙවීම)</li>
                                <li><strong>O(n)</strong> - රේඛීය කාලය (උදා: රේඛීය සෙවීම)</li>
                                <li><strong>O(n log n)</strong> - රේඛීය-ලඝුගණක කාලය (උදා: ඒකාබද්ධ වර්ග කිරීම)</li>
                                <li><strong>O(n²)</strong> - චතුරස්‍ර කාලය (උදා: බුබුළු වර්ග කිරීම)</li>
                                <li><strong>O(2ⁿ)</strong> - ඝාතීය කාලය (උදා: පුනරාවර්තන fibonacci)</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        b) Illustrate the time complexities of insertion, deletion, and search operations for an array-based list.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q1b-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q1b-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q1b-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Operation</th>
                                    <th>Best Case</th>
                                    <th>Average Case</th>
                                    <th>Worst Case</th>
                                    <th>Explanation</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Insertion</strong></td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>At end: O(1), At beginning/middle: O(n) due to shifting</td>
                                </tr>
                                <tr>
                                    <td><strong>Deletion</strong></td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>At end: O(1), At beginning/middle: O(n) due to shifting</td>
                                </tr>
                                <tr>
                                    <td><strong>Search (Unsorted)</strong></td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>Linear search required</td>
                                </tr>
                                <tr>
                                    <td><strong>Search (Sorted)</strong></td>
                                    <td>O(1)</td>
                                    <td>O(log n)</td>
                                    <td>O(log n)</td>
                                    <td>Binary search possible</td>
                                </tr>
                                <tr>
                                    <td><strong>Access by Index</strong></td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                    <td>Direct memory access</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>Detailed Explanation:</h4>
                        
                        <div class="definition-box">
                            <strong>1. Insertion:</strong>
                            <ul>
                                <li><strong>At End:</strong> O(1) - Simply add at next available position</li>
                                <li><strong>At Beginning:</strong> O(n) - Must shift all elements right</li>
                                <li><strong>At Position i:</strong> O(n) - Must shift (n-i) elements right</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>2. Deletion:</strong>
                            <ul>
                                <li><strong>At End:</strong> O(1) - Simply remove last element</li>
                                <li><strong>At Beginning:</strong> O(n) - Must shift all elements left</li>
                                <li><strong>At Position i:</strong> O(n) - Must shift (n-i-1) elements left</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>3. Search:</strong>
                            <ul>
                                <li><strong>Unsorted Array:</strong> O(n) - Must check each element (linear search)</li>
                                <li><strong>Sorted Array:</strong> O(log n) - Can use binary search</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q1b-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>ක්‍රියාව</th>
                                    <th>හොඳම අවස්ථාව</th>
                                    <th>සාමාන්‍ය අවස්ථාව</th>
                                    <th>නරකම අවස්ථාව</th>
                                    <th>පැහැදිලි කිරීම</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>ඇතුළත් කිරීම</strong></td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>අවසානයේ: O(1), ආරම්භයේ/මැදින්: O(n) මාරු වීම නිසා</td>
                                </tr>
                                <tr>
                                    <td><strong>මකා දැමීම</strong></td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>අවසානයේ: O(1), ආරම්භයේ/මැදින්: O(n) මාරු වීම නිසා</td>
                                </tr>
                                <tr>
                                    <td><strong>සෙවීම (නොවර්ග)</strong></td>
                                    <td>O(1)</td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>රේඛීය සෙවීම අවශ්‍යයි</td>
                                </tr>
                                <tr>
                                    <td><strong>සෙවීම (වර්ග)</strong></td>
                                    <td>O(1)</td>
                                    <td>O(log n)</td>
                                    <td>O(log n)</td>
                                    <td>ද්විමය සෙවීම හැකියි</td>
                                </tr>
                                <tr>
                                    <td><strong>දර්ශකයෙන් ප්‍රවේශය</strong></td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                    <td>සෘජු මතක ප්‍රවේශය</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>විස්තරාත්මක පැහැදිලි කිරීම:</h4>
                        
                        <div class="definition-box">
                            <strong>1. ඇතුළත් කිරීම:</strong>
                            <ul>
                                <li><strong>අවසානයේ:</strong> O(1) - මීළඟ ලබා ගත හැකි ස්ථානයේ එක් කරන්න</li>
                                <li><strong>ආරම්භයේ:</strong> O(n) - සියලුම මූලද්‍රව්‍ය දකුණට මාරු කළ යුතුය</li>
                                <li><strong>i ස්ථානයේ:</strong> O(n) - (n-i) මූලද්‍රව්‍ය දකුණට මාරු කළ යුතුය</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>2. මකා දැමීම:</strong>
                            <ul>
                                <li><strong>අවසානයේ:</strong> O(1) - අවසාන මූලද්‍රව්‍යය ඉවත් කරන්න</li>
                                <li><strong>ආරම්භයේ:</strong> O(n) - සියලුම මූලද්‍රව්‍ය වමට මාරු කළ යුතුය</li>
                                <li><strong>i ස්ථානයේ:</strong> O(n) - (n-i-1) මූලද්‍රව්‍ය වමට මාරු කළ යුතුය</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        c) Explain the differences between static and dynamic data structures, providing relevant examples.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q1c-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q1c-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q1c-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Static Data Structures</th>
                                    <th>Dynamic Data Structures</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Size</strong></td>
                                    <td>Fixed at compile time</td>
                                    <td>Can grow/shrink at runtime</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory Allocation</strong></td>
                                    <td>Compile-time (Stack)</td>
                                    <td>Runtime (Heap)</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory Usage</strong></td>
                                    <td>May waste space if underutilized</td>
                                    <td>Efficient, uses only needed space</td>
                                </tr>
                                <tr>
                                    <td><strong>Access Speed</strong></td>
                                    <td>Faster (contiguous memory)</td>
                                    <td>Slower (pointer traversal)</td>
                                </tr>
                                <tr>
                                    <td><strong>Flexibility</strong></td>
                                    <td>Less flexible</td>
                                    <td>More flexible</td>
                                </tr>
                                <tr>
                                    <td><strong>Examples</strong></td>
                                    <td>Arrays</td>
                                    <td>Linked Lists, Trees, Graphs</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>Static Data Structures:</h4>
                        <div class="definition-box">
                            <strong>Characteristics:</strong>
                            <ul>
                                <li>Size must be declared at compile time</li>
                                <li>Memory allocated in contiguous block</li>
                                <li>Cannot change size during execution</li>
                                <li>Memory is allocated on stack</li>
                            </ul>
                            
                            <strong>Example - Array:</strong>
                            <div class="code-block">
<pre><span class="keyword">int</span> arr[<span class="number">100</span>]; <span class="comment">// Size fixed at 100</span>
<span class="comment">// Cannot add 101st element</span></pre>
                            </div>

                            <strong>Advantages:</strong>
                            <ul>
                                <li>Fast access time O(1)</li>
                                <li>Simple implementation</li>
                                <li>Cache friendly</li>
                            </ul>

                            <strong>Disadvantages:</strong>
                            <ul>
                                <li>Fixed size - inflexible</li>
                                <li>Memory waste if not fully used</li>
                                <li>Cannot grow beyond initial size</li>
                            </ul>
                        </div>

                        <h4>Dynamic Data Structures:</h4>
                        <div class="definition-box">
                            <strong>Characteristics:</strong>
                            <ul>
                                <li>Size determined at runtime</li>
                                <li>Memory allocated as needed</li>
                                <li>Can grow or shrink during execution</li>
                                <li>Memory allocated on heap</li>
                            </ul>
                            
                            <strong>Example - Linked List:</strong>
                            <div class="code-block">
<pre><span class="keyword">struct</span> <span class="type">Node</span> {
    <span class="keyword">int</span> data;
    <span class="keyword">struct</span> <span class="type">Node</span>* next;
};
<span class="comment">// Can add unlimited nodes dynamically</span></pre>
                            </div>

                            <strong>Advantages:</strong>
                            <ul>
                                <li>Flexible size</li>
                                <li>Efficient memory usage</li>
                                <li>Easy insertion/deletion</li>
                            </ul>

                            <strong>Disadvantages:</strong>
                            <ul>
                                <li>Slower access O(n)</li>
                                <li>Extra memory for pointers</li>
                                <li>More complex implementation</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q1c-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>අංගය</th>
                                    <th>ස්ථිතික දත්ත ව්‍යුහයන්</th>
                                    <th>ගතික දත්ත ව්‍යුහයන්</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>ප්‍රමාණය</strong></td>
                                    <td>සම්පාදන කාලයේ ස්ථාවරයි</td>
                                    <td>ධාවන කාලයේ වර්ධනය/හැකිළිය හැක</td>
                                </tr>
                                <tr>
                                    <td><strong>මතක වෙන් කිරීම</strong></td>
                                    <td>සම්පාදන කාලය (Stack)</td>
                                    <td>ධාවන කාලය (Heap)</td>
                                </tr>
                                <tr>
                                    <td><strong>මතක භාවිතය</strong></td>
                                    <td>අඩුවෙන් භාවිත වුවහොත් අපතේ යා හැක</td>
                                    <td>කාර්යක්ෂම, අවශ්‍ය ඉඩ පමණක් භාවිත කරයි</td>
                                </tr>
                                <tr>
                                    <td><strong>ප්‍රවේශ වේගය</strong></td>
                                    <td>වේගවත් (අඛණ්ඩ මතකය)</td>
                                    <td>මන්දගාමී (දර්ශක හරහා ගමන්)</td>
                                </tr>
                                <tr>
                                    <td><strong>නම්‍යශීලීභාවය</strong></td>
                                    <td>අඩු නම්‍යශීලී</td>
                                    <td>වැඩි නම්‍යශීලී</td>
                                </tr>
                                <tr>
                                    <td><strong>උදාහරණ</strong></td>
                                    <td>අරා (Arrays)</td>
                                    <td>සම්බන්ධිත ලැයිස්තු, ගස්, ප්‍රස්ථාර</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>ස්ථිතික දත්ත ව්‍යුහයන්:</h4>
                        <div class="definition-box">
                            <strong>ලක්ෂණ:</strong>
                            <ul>
                                <li>ප්‍රමාණය සම්පාදන කාලයේ ප්‍රකාශ කළ යුතුය</li>
                                <li>අඛණ්ඩ කොටසක මතකය වෙන් කරනු ලැබේ</li>
                                <li>ක්‍රියාත්මක වීමේදී ප්‍රමාණය වෙනස් කළ නොහැක</li>
                                <li>stack හි මතකය වෙන් කරනු ලැබේ</li>
                            </ul>
                        </div>

                        <h4>ගතික දත්ත ව්‍යුහයන්:</h4>
                        <div class="definition-box">
                            <strong>ලක්ෂණ:</strong>
                            <ul>
                                <li>ප්‍රමාණය ධාවන කාලයේ තීරණය වේ</li>
                                <li>අවශ්‍ය පරිදි මතකය වෙන් කරනු ලැබේ</li>
                                <li>ක්‍රියාත්මක වීමේදී වර්ධනය හෝ හැකිළිය හැක</li>
                                <li>heap හි මතකය වෙන් කරනු ලැබේ</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        d) Analyze why a sorting algorithm with quadratic time complexity (O(n²)), such as Bubble Sort, is inefficient for large datasets.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q1d-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q1d-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q1d-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <h4>Why O(n²) is Inefficient for Large Datasets:</h4>
                        
                        <div class="definition-box">
                            <strong>Growth Rate Analysis:</strong>
                            <p>Quadratic complexity means the number of operations grows proportionally to the square of input size.</p>
                            
                            <table class="comparison-table" style="margin-top: 15px;">
                                <thead>
                                    <tr>
                                        <th>Input Size (n)</th>
                                        <th>Operations (n²)</th>
                                        <th>Time (assuming 1μs/op)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>10</td>
                                        <td>100</td>
                                        <td>0.1 milliseconds</td>
                                    </tr>
                                    <tr>
                                        <td>100</td>
                                        <td>10,000</td>
                                        <td>10 milliseconds</td>
                                    </tr>
                                    <tr>
                                        <td>1,000</td>
                                        <td>1,000,000</td>
                                        <td>1 second</td>
                                    </tr>
                                    <tr>
                                        <td>10,000</td>
                                        <td>100,000,000</td>
                                        <td>100 seconds</td>
                                    </tr>
                                    <tr>
                                        <td>100,000</td>
                                        <td>10,000,000,000</td>
                                        <td>10,000 seconds (~2.7 hours)</td>
                                    </tr>
                                    <tr style="background: #ffebee;">
                                        <td>1,000,000</td>
                                        <td>1,000,000,000,000</td>
                                        <td>1,000,000 seconds (~11.5 days)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h4>Key Problems with O(n²) for Large Data:</h4>
                        
                        <div class="example-box">
                            <strong>1. Exponential Growth:</strong>
                            <ul>
                                <li>Doubling input size quadruples execution time</li>
                                <li>10x input → 100x execution time</li>
                                <li>Becomes impractical very quickly</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <strong>2. Resource Consumption:</strong>
                            <ul>
                                <li>CPU usage becomes excessive</li>
                                <li>System becomes unresponsive</li>
                                <li>Power consumption increases significantly</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <strong>3. Scalability Issues:</strong>
                            <ul>
                                <li>Cannot handle modern data volumes</li>
                                <li>Big data applications require millions/billions of records</li>
                                <li>O(n²) algorithms fail at this scale</li>
                            </ul>
                        </div>

                        <h4>Comparison with Better Algorithms:</h4>
                        <div class="code-block">
<pre><span class="comment">// For n = 1,000,000 elements:</span>

<span class="comment">// Bubble Sort (O(n²)):</span>
Operations: 1,000,000² = 1,000,000,000,000 (1 trillion)
Time: ~11.5 days

<span class="comment">// Quick Sort (O(n log n)):</span>
Operations: 1,000,000 × log₂(1,000,000) ≈ 20,000,000
Time: ~20 seconds

<span class="comment">// Speed improvement: ~50,000x faster!</span></pre>
                        </div>

                        <div class="note-box">
                            <strong>Conclusion:</strong> While O(n²) algorithms like Bubble Sort work fine for small datasets (n < 100), they become completely impractical for large datasets. Modern applications require O(n log n) algorithms like Quick Sort, Merge Sort, or Heap Sort for efficient sorting of large data volumes.
                        </div>
                    </div>

                    <div id="q1d-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <h4>විශාල දත්ත කට්ටල සඳහා O(n²) අකාර්යක්ෂම වන්නේ ඇයි:</h4>
                        
                        <div class="definition-box">
                            <strong>වර්ධන වේග විශ්ලේෂණය:</strong>
                            <p>චතුරස්‍ර සංකීර්ණත්වය යන්නෙන් අදහස් වන්නේ ක්‍රියාකාරකම් ගණන ආදාන ප්‍රමාණයේ වර්ගයට සමානුපාතිකව වර්ධනය වීමයි.</p>
                        </div>

                        <h4>O(n²) සමඟ ඇති ප්‍රධාන ගැටළු:</h4>
                        
                        <div class="example-box">
                            <strong>1. ඝාතීය වර්ධනය:</strong>
                            <ul>
                                <li>ආදාන ප්‍රමාණය දෙගුණ කිරීම ක්‍රියාත්මක කාලය හතර ගුණයක් කරයි</li>
                                <li>10x ආදානය → 100x ක්‍රියාත්මක කාලය</li>
                                <li>ඉතා ඉක්මනින් ප්‍රායෝගික නොවේ</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <strong>2. සම්පත් පරිභෝජනය:</strong>
                            <ul>
                                <li>CPU භාවිතය අධික වේ</li>
                                <li>පද්ධතිය ප්‍රතිචාර නොදක්වයි</li>
                                <li>බල පරිභෝජනය සැලකිය යුතු ලෙස වැඩි වේ</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <strong>3. පරිමාණ ගැටළු:</strong>
                            <ul>
                                <li>නවීන දත්ත පරිමාවන් හැසිරවිය නොහැක</li>
                                <li>විශාල දත්ත යෙදුම්වලට මිලියන/බිලියන වාර්තා අවශ්‍යයි</li>
                                <li>O(n²) ඇල්ගොරිතම මෙම පරිමාණයේදී අසමත් වේ</li>
                            </ul>
                        </div>

                        <div class="note-box">
                            <strong>නිගමනය:</strong> O(n²) ඇල්ගොරිතම කුඩා දත්ත කට්ටල සඳහා (n < 100) හොඳින් ක්‍රියා කළත්, විශාල දත්ත කට්ටල සඳහා ඒවා සම්පූර්ණයෙන්ම අප්‍රායෝගික වේ. නවීන යෙදුම් සඳහා Quick Sort, Merge Sort හෝ Heap Sort වැනි O(n log n) ඇල්ගොරිතම අවශ්‍ය වේ.
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        e) Suppose you are designing an application that must handle millions of data transactions per second. What performance considerations would you prioritize, and how would you optimize your algorithms?
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q1e-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q1e-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q1e-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <h4>Key Performance Considerations:</h4>
                        
                        <div class="definition-box">
                            <strong>1. Time Complexity Optimization:</strong>
                            <ul>
                                <li><strong>Priority:</strong> Use O(1) or O(log n) algorithms wherever possible</li>
                                <li><strong>Avoid:</strong> O(n²) or higher complexity algorithms</li>
                                <li><strong>Implementation:</strong> Hash tables for O(1) lookups, binary search trees for O(log n) operations</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>2. Data Structure Selection:</strong>
                            <ul>
                                <li><strong>Hash Maps/Tables:</strong> For fast key-value lookups (O(1))</li>
                                <li><strong>B-Trees/B+ Trees:</strong> For database indexing (O(log n))</li>
                                <li><strong>Priority Queues:</strong> For managing task priorities efficiently</li>
                                <li><strong>Lock-free Data Structures:</strong> For concurrent access without blocking</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>3. Memory Management:</strong>
                            <ul>
                                <li><strong>Cache Optimization:</strong> Keep frequently accessed data in cache</li>
                                <li><strong>Memory Pooling:</strong> Pre-allocate memory to avoid runtime allocation overhead</li>
                                <li><strong>Data Locality:</strong> Arrange data for sequential access patterns</li>
                                <li><strong>Avoid Memory Fragmentation:</strong> Use fixed-size allocations where possible</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>4. Parallelization & Concurrency:</strong>
                            <ul>
                                <li><strong>Multi-threading:</strong> Process transactions in parallel</li>
                                <li><strong>Load Balancing:</strong> Distribute work across multiple processors</li>
                                <li><strong>Lock-free Algorithms:</strong> Reduce contention in concurrent operations</li>
                                <li><strong>Asynchronous Processing:</strong> Non-blocking I/O operations</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>5. Batch Processing:</strong>
                            <ul>
                                <li><strong>Group Operations:</strong> Process multiple transactions together</li>
                                <li><strong>Reduce Overhead:</strong> Minimize per-transaction costs</li>
                                <li><strong>Amortization:</strong> Spread fixed costs over multiple operations</li>
                            </ul>
                        </div>

                        <h4>Specific Optimization Strategies:</h4>
                        
                        <div class="example-box">
                            <strong>Algorithm Optimizations:</strong>
                            <div class="code-block">
<pre><span class="comment">// Instead of O(n) linear search:</span>
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
    <span class="keyword">if</span> (data[i] == target) <span class="keyword">return</span> i;
}

<span class="comment">// Use O(1) hash table lookup:</span>
unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashMap;
<span class="keyword">return</span> hashMap[target]; <span class="comment">// O(1) average case</span></pre>
                            </div>
                        </div>

                        <div class="example-box">
                            <strong>Caching Strategy:</strong>
                            <ul>
                                <li>Implement LRU (Least Recently Used) cache</li>
                                <li>Cache frequently accessed data in memory</li>
                                <li>Use CDN for distributed caching</li>
                            </ul>
                        </div>

                        <div class="example-box">
                            <strong>Database Optimization:</strong>
                            <ul>
                                <li>Proper indexing (B-tree, hash indexes)</li>
                                <li>Query optimization (avoid full table scans)</li>
                                <li>Database sharding for horizontal scaling</li>
                                <li>Read replicas for load distribution</li>
                            </ul>
                        </div>

                        <div class="note-box">
                            <strong>Trade-offs to Consider:</strong>
                            <ul>
                                <li><strong>Speed vs Memory:</strong> Caching uses more memory but increases speed</li>
                                <li><strong>Consistency vs Availability:</strong> CAP theorem considerations</li>
                                <li><strong>Complexity vs Maintainability:</strong> Complex optimizations may be harder to maintain</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q1e-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <h4>ප්‍රධාන ක්‍රියාකාරිත්ව සැලකිලි:</h4>
                        
                        <div class="definition-box">
                            <strong>1. කාල සංකීර්ණත්ව ප්‍රශස්තිකරණය:</strong>
                            <ul>
                                <li>හැකි තැන් වල O(1) හෝ O(log n) ඇල්ගොරිතම භාවිතා කරන්න</li>
                                <li>O(n²) හෝ ඉහළ සංකීර්ණත්ව ඇල්ගොරිතම වළක්වන්න</li>
                                <li>O(1) සෙවීම් සඳහා හැෂ් වගු භාවිතා කරන්න</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>2. දත්ත ව්‍යුහ තෝරා ගැනීම:</strong>
                            <ul>
                                <li><strong>හැෂ් සිතියම්/වගු:</strong> වේගවත් සෙවීම් සඳහා (O(1))</li>
                                <li><strong>B-ගස්/B+ ගස්:</strong> දත්ත සමුදා දර්ශක සඳහා (O(log n))</li>
                                <li><strong>ප්‍රමුඛතා පෝලිම්:</strong> කාර්ය ප්‍රමුඛතා කාර්යක්ෂමව කළමනාකරණය</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>3. මතක කළමනාකරණය:</strong>
                            <ul>
                                <li><strong>කැෂේ ප්‍රශස්තිකරණය:</strong> නිතර ප්‍රවේශ වන දත්ත කැෂේ හි තබන්න</li>
                                <li><strong>මතක එකතු කිරීම:</strong> ධාවන කාලයේ වෙන් කිරීම් වළක්වන්න</li>
                                <li><strong>දත්ත ප්‍රදේශීයත්වය:</strong> අනුක්‍රමික ප්‍රවේශ රටා සඳහා දත්ත සකස් කරන්න</li>
                            </ul>
                        </div>

                        <div class="definition-box">
                            <strong>4. සමාන්තරකරණය සහ සමගාමීත්වය:</strong>
                            <ul>
                                <li><strong>බහු-නූල්:</strong> ගනුදෙනු සමාන්තරව සකස් කරන්න</li>
                                <li><strong>බර සමතුලිත කිරීම:</strong> බහු ප්‍රොසෙසර හරහා වැඩ බෙදා හරින්න</li>
                                <li><strong>අගුළු-නිදහස් ඇල්ගොරිතම:</strong> සමගාමී ක්‍රියාකාරකම්වල ආරවුල අඩු කරන්න</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- QUESTION 2 -->
            <div class="question-block">
                <div class="question-number">Question 2</div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        a) What is an array? How does it differ from a linked list in terms of memory allocation and access time?
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q2a-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q2a-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q2a-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <div class="definition-box">
                            <strong>Array Definition:</strong>
                            <p>An array is a data structure that stores a fixed-size sequential collection of elements of the same type in contiguous memory locations. Each element can be accessed directly using an index.</p>
                        </div>

                        <h4>Key Differences:</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Array</th>
                                    <th>Linked List</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Memory Allocation</strong></td>
                                    <td>Contiguous memory block</td>
                                    <td>Non-contiguous, scattered in heap</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory Location</strong></td>
                                    <td>Stack (static) or Heap (dynamic)</td>
                                    <td>Heap only</td>
                                </tr>
                                <tr>
                                    <td><strong>Size</strong></td>
                                    <td>Fixed at creation</td>
                                    <td>Dynamic, can grow/shrink</td>
                                </tr>
                                <tr>
                                    <td><strong>Access Time</strong></td>
                                    <td>O(1) - Direct access by index</td>
                                    <td>O(n) - Sequential traversal required</td>
                                </tr>
                                <tr>
                                    <td><strong>Insertion (Beginning)</strong></td>
                                    <td>O(n) - Must shift elements</td>
                                    <td>O(1) - Update head pointer</td>
                                </tr>
                                <tr>
                                    <td><strong>Deletion (Beginning)</strong></td>
                                    <td>O(n) - Must shift elements</td>
                                    <td>O(1) - Update head pointer</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory Overhead</strong></td>
                                    <td>None - stores only data</td>
                                    <td>Extra memory for pointers</td>
                                </tr>
                                <tr>
                                    <td><strong>Cache Performance</strong></td>
                                    <td>Better - cache friendly</td>
                                    <td>Worse - cache misses</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>Memory Allocation Visualization:</h4>
                        <div class="code-block">
<pre><span class="comment">// ARRAY - Contiguous Memory</span>
Memory Address: 1000  1004  1008  1012  1016
Array Elements: [ 10 | 20 | 30 | 40 | 50 ]
                  ↑
                arr  arr[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)]  arr[[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)]  arr[[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG2Po4MiNFficjSVE9lt0YC0UdZe_IyEwf4n3NdGQ7EamuW-oAJejZ9UeBiswfLF1j_fSVf9CcdBNwJJ4GDS63WjGTU8ZwpsRF-QNSIxQM1WTBM8Ffpvh9kuZVrEZfLQ4o7nLrrwfYA7LCdGtmRTctp2l7Y7TgH)]  arr[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)]
<span class="comment">// Direct access: arr[[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)] = *(arr + 2) = memory[[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHa6oTCUSminEZ2jA1n2_Dqft0dIqgRMlLhQ-w6XOIIxXgRriCRjbS6BJnW6ELVOY6wVRn6OlSDT4Sxez7P77hi5xvUrFJDL4Njpp301EFmhovaxcP_4M5cVzpIVxKBaEmgYryFXb2djRl4QP9BNXGKv9yTKCH_9vN5VgY4bw3e9qW1lblSaWw%3D)]</span>

<span class="comment">// LINKED LIST - Non-contiguous Memory</span>
Node 1 (addr: 1000): [data: 10 | next: 1500] ──┐
                                                 │
Node 2 (addr: 1500): [data: 20 | next: 2200] ←─┘
                                                 │
Node 3 (addr: 2200): [data: 30 | next: 1800] ←─┘
                                                 │
Node 4 (addr: 1800): [data: 40 | next: NULL] ←─┘
<span class="comment">// Must traverse: head→next→next to reach 3rd node</span></pre>
                        </div>

                        <h4>Access Time Comparison:</h4>
                        <div class="example-box">
                            <strong>Array - O(1) Access:</strong>
                            <div class="code-block">
<pre><span class="keyword">int</span> arr[<span class="number">5</span>] = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};
<span class="keyword">int</span> value = arr[<span class="number">2</span>]; <span class="comment">// Direct access, O(1)</span>
<span class="comment">// Calculation: address = base + (index × size)</span></pre>
                            </div>

                            <strong>Linked List - O(n) Access:</strong>
                            <div class="code-block">
<pre><span class="keyword">struct</span> <span class="type">Node</span>* current = head;
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) {
    current = current-&gt;next; <span class="comment">// Must traverse, O(n)</span>
}
<span class="keyword">int</span> value = current-&gt;data;</pre>
                            </div>
                        </div>
                    </div>

                    <div id="q2a-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <div class="definition-box">
                            <strong>අරා අර්ථ දැක්වීම:</strong>
                            <p>අරා යනු එකම වර්ගයේ මූලද්‍රව්‍ය නියත-ප්‍රමාණයේ අනුක්‍රමික එකතුවක් අඛණ්ඩ මතක ස්ථානවල ගබඩා කරන දත්ත ව්‍යුහයකි. දර්ශකයක් භාවිතයෙන් සෑම මූලද්‍රව්‍යයකටම සෘජුවම ප්‍රවේශ විය හැක.</p>
                        </div>

                        <h4>ප්‍රධාන වෙනස්කම්:</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>අංගය</th>
                                    <th>අරා (Array)</th>
                                    <th>සම්බන්ධිත ලැයිස්තුව</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>මතක වෙන් කිරීම</strong></td>
                                    <td>අඛණ්ඩ මතක කොටස</td>
                                    <td>අඛණ්ඩ නොවන, heap හි විසිරී</td>
                                </tr>
                                <tr>
                                    <td><strong>ප්‍රවේශ කාලය</strong></td>
                                    <td>O(1) - දර්ශකයෙන් සෘජු ප්‍රවේශය</td>
                                    <td>O(n) - අනුක්‍රමික ගමන් කිරීම අවශ්‍යයි</td>
                                </tr>
                                <tr>
                                    <td><strong>ප්‍රමාණය</strong></td>
                                    <td>නිර්මාණයේදී ස්ථාවරයි</td>
                                    <td>ගතික, වර්ධනය/හැකිළිය හැක</td>
                                </tr>
                                <tr>
                                    <td><strong>මතක අතිරික්තය</strong></td>
                                    <td>නැත - දත්ත පමණක් ගබඩා කරයි</td>
                                    <td>දර්ශක සඳහා අමතර මතකය</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        b) Analyze the time complexity of searching for an element in an unsorted array compared to a singly linked list.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q2b-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q2b-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q2b-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <div class="definition-box">
                            <strong>Both have O(n) time complexity for searching in unsorted data, but with different characteristics.</strong>
                        </div>

                        <h4>1. Unsorted Array Search:</h4>
                        <div class="code-block">
<pre><span class="keyword">int</span> <span class="function">searchArray</span>(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target) {
    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {
        <span class="keyword">if</span>(arr[i] == target)
            <span class="keyword">return</span> i; <span class="comment">// Found at index i</span>
    }
    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Not found</span>
}

<span class="comment">// Time Complexity: O(n)</span>
<span class="comment">// Space Complexity: O(1)</span></pre>
                        </div>

                        <h4>2. Singly Linked List Search:</h4>
                        <div class="code-block">
<pre><span class="keyword">struct</span> <span class="type">Node</span>* <span class="function">searchLinkedList</span>(<span class="keyword">struct</span> <span class="type">Node</span>* head, <span class="keyword">int</span> target) {
    <span class="keyword">struct</span> <span class="type">Node</span>* current = head;
    
    <span class="keyword">while</span>(current != <span class="keyword">NULL</span>) {
        <span class="keyword">if</span>(current-&gt;data == target)
            <span class="keyword">return</span> current; <span class="comment">// Found</span>
        current = current-&gt;next;
    }
    <span class="keyword">return</span> <span class="keyword">NULL</span>; <span class="comment">// Not found</span>
}

<span class="comment">// Time Complexity: O(n)</span>
<span class="comment">// Space Complexity: O(1)</span></pre>
                        </div>

                        <h4>Detailed Comparison:</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Unsorted Array</th>
                                    <th>Singly Linked List</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Time Complexity</strong></td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr>
                                    <td><strong>Best Case</strong></td>
                                    <td>O(1) - Element at index 0</td>
                                    <td>O(1) - Element at head</td>
                                </tr>
                                <tr>
                                    <td><strong>Worst Case</strong></td>
                                    <td>O(n) - Element at end or not found</td>
                                    <td>O(n) - Element at tail or not found</td>
                                </tr>
                                <tr>
                                    <td><strong>Average Case</strong></td>
                                    <td>O(n/2) = O(n)</td>
                                    <td>O(n/2) = O(n)</td>
                                </tr>
                                <tr>
                                    <td><strong>Cache Performance</strong></td>
                                    <td>Better - contiguous memory</td>
                                    <td>Worse - cache misses</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory Access Pattern</strong></td>
                                    <td>Sequential, predictable</td>
                                    <td>Random, unpredictable</td>
                                </tr>
                                <tr>
                                    <td><strong>Practical Performance</strong></td>
                                    <td>Faster due to cache locality</td>
                                    <td>Slower due to pointer chasing</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="note-box">
                            <strong>Key Insight:</strong> While both have O(n) theoretical complexity, arrays are typically 2-5x faster in practice due to:
                            <ul>
                                <li>Better cache utilization (spatial locality)</li>
                                <li>No pointer dereferencing overhead</li>
                                <li>CPU prefetching optimizations</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q2b-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <div class="definition-box">
                            <strong>නොවර්ග කළ දත්තවල සෙවීම සඳහා දෙකටම O(n) කාල සංකීර්ණත්වයක් ඇත, නමුත් විවිධ ලක්ෂණ සහිතව.</strong>
                        </div>

                        <h4>විස්තරාත්මක සංසන්දනය:</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>අංගය</th>
                                    <th>නොවර්ග අරා</th>
                                    <th>තනි සම්බන්ධිත ලැයිස්තුව</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>කාල සංකීර්ණත්වය</strong></td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                </tr>
                                <tr>
                                    <td><strong>හොඳම අවස්ථාව</strong></td>
                                    <td>O(1) - දර්ශකය 0 හි මූලද්‍රව්‍යය</td>
                                    <td>O(1) - ප්‍රධානයේ මූලද්‍රව්‍යය</td>
                                </tr>
                                <tr>
                                    <td><strong>නරකම අවස්ථාව</strong></td>
                                    <td>O(n) - අවසානයේ හෝ නොමැත</td>
                                    <td>O(n) - වලිගයේ හෝ නොමැත</td>
                                </tr>
                                <tr>
                                    <td><strong>කැෂේ ක්‍රියාකාරිත්වය</strong></td>
                                    <td>හොඳයි - අඛණ්ඩ මතකය</td>
                                    <td>නරකයි - කැෂේ මග හැරීම්</td>
                                </tr>
                            </tbody>
                        </table>

                        <div class="note-box">
                            <strong>ප්‍රධාන තීක්ෂ්ණ බව:</strong> දෙකටම O(n) න්‍යායික සංකීර්ණත්වයක් ඇතත්, අරා සාමාන්‍යයෙන් 2-5x වේගවත් වේ:
                            <ul>
                                <li>හොඳ කැෂේ උපයෝජනය</li>
                                <li>දර්ශක අවලංගු කිරීමේ අතිරික්තය නැත</li>
                                <li>CPU පූර්ව ලබා ගැනීමේ ප්‍රශස්තිකරණයන්</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        c) Implement a function in C/C++ to remove an element from a given position of a singly linked list.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q2c-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q2c-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q2c-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <div class="code-block">
<pre><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;stdlib.h&gt;</span>

<span class="comment">// Node structure definition</span>
<span class="keyword">struct</span> <span class="type">Node</span> {
    <span class="keyword">int</span> data;
    <span class="keyword">struct</span> <span class="type">Node</span>* next;
};

<span class="comment">// Function to remove element at given position</span>
<span class="keyword">struct</span> <span class="type">Node</span>* <span class="function">removeAtPosition</span>(<span class="keyword">struct</span> <span class="type">Node</span>* head, <span class="keyword">int</span> position) {
    <span class="comment">// Case 1: Empty list</span>
    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) {
        <span class="function">printf</span>(<span class="string">"List is empty\n"</span>);
        <span class="keyword">return</span> head;
    }
    
    <span class="comment">// Case 2: Remove first node (position 0)</span>
    <span class="keyword">if</span> (position == <span class="number">0</span>) {
        <span class="keyword">struct</span> <span class="type">Node</span>* temp = head;
        head = head-&gt;next;
        <span class="function">free</span>(temp);
        <span class="keyword">return</span> head;
    }
    
    <span class="comment">// Case 3: Remove node at position &gt; 0</span>
    <span class="keyword">struct</span> <span class="type">Node</span>* current = head;
    <span class="keyword">struct</span> <span class="type">Node</span>* previous = <span class="keyword">NULL</span>;
    <span class="keyword">int</span> count = <span class="number">0</span>;
    
    <span class="comment">// Traverse to the node at given position</span>
    <span class="keyword">while</span> (current != <span class="keyword">NULL</span> &amp;&amp; count &lt; position) {
        previous = current;
        current = current-&gt;next;
        count++;
    }
    
    <span class="comment">// Position out of range</span>
    <span class="keyword">if</span> (current == <span class="keyword">NULL</span>) {
        <span class="function">printf</span>(<span class="string">"Position %d is out of range\n"</span>, position);
        <span class="keyword">return</span> head;
    }
    
    <span class="comment">// Remove the node</span>
    previous-&gt;next = current-&gt;next;
    <span class="function">free</span>(current);
    
    <span class="keyword">return</span> head;
}

<span class="comment">// Helper function to create a new node</span>
<span class="keyword">struct</span> <span class="type">Node</span>* <span class="function">createNode</span>(<span class="keyword">int</span> data) {
    <span class="keyword">struct</span> <span class="type">Node</span>* newNode = 
        (<span class="keyword">struct</span> <span class="type">Node</span>*)<span class="function">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="type">Node</span>));
    newNode-&gt;data = data;
    newNode-&gt;next = <span class="keyword">NULL</span>;
    <span class="keyword">return</span> newNode;
}

<span class="comment">// Helper function to print the list</span>
<span class="keyword">void</span> <span class="function">printList</span>(<span class="keyword">struct</span> <span class="type">Node</span>* head) {
    <span class="keyword">struct</span> <span class="type">Node</span>* current = head;
    <span class="keyword">while</span> (current != <span class="keyword">NULL</span>) {
        <span class="function">printf</span>(<span class="string">"%d -&gt; "</span>, current-&gt;data);
        current = current-&gt;next;
    }
    <span class="function">printf</span>(<span class="string">"NULL\n"</span>);
}

<span class="comment">// Test the function</span>
<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Create list: 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; 50</span>
    <span class="keyword">struct</span> <span class="type">Node</span>* head = <span class="function">createNode</span>(<span class="number">10</span>);
    head-&gt;next = <span class="function">createNode</span>(<span class="number">20</span>);
    head-&gt;next-&gt;next = <span class="function">createNode</span>(<span class="number">30</span>);
    head-&gt;next-&gt;next-&gt;next = <span class="function">createNode</span>(<span class="number">40</span>);
    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="function">createNode</span>(<span class="number">50</span>);
    
    <span class="function">printf</span>(<span class="string">"Original list: "</span>);
    <span class="function">printList</span>(head);
    
    <span class="comment">// Remove element at position 2</span>
    head = <span class="function">removeAtPosition</span>(head, <span class="number">2</span>);
    <span class="function">printf</span>(<span class="string">"After removing position 2: "</span>);
    <span class="function">printList</span>(head);
    
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">/* 
Output:
Original list: 10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; 50 -&gt; NULL
After removing position 2: 10 -&gt; 20 -&gt; 40 -&gt; 50 -&gt; NULL
*/</span></pre>
                        </div>

                        <h4>Complexity Analysis:</h4>
                        <div class="definition-box">
                            <ul>
                                <li><strong>Time Complexity:</strong> O(n) where n is the position</li>
                                <li><strong>Space Complexity:</strong> O(1) - constant extra space</li>
                            </ul>
                        </div>

                        <h4>Key Points:</h4>
                        <div class="example-box">
                            <ol>
                                <li>Handle empty list case</li>
                                <li>Special case for removing head (position 0)</li>
                                <li>Maintain previous pointer for linking</li>
                                <li>Check for position out of range</li>
                                <li>Free memory to avoid memory leaks</li>
                                <li>Return updated head pointer</li>
                            </ol>
                        </div>
                    </div>

                    <div id="q2c-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <p>ඉහත කේතය දී ඇති ස්ථානයකින් මූලද්‍රව්‍යයක් ඉවත් කරන්නේ කෙසේදැයි පෙන්වයි.</p>

                        <h4>සංකීර්ණත්ව විශ්ලේෂණය:</h4>
                        <div class="definition-box">
                            <ul>
                                <li><strong>කාල සංකීර්ණත්වය:</strong> O(n) n යනු ස්ථානයයි</li>
                                <li><strong>අවකාශ සංකීර්ණත්වය:</strong> O(1) - ස්ථාවර අමතර ඉඩ</li>
                            </ul>
                        </div>

                        <h4>ප්‍රධාන කරුණු:</h4>
                        <div class="example-box">
                            <ol>
                                <li>හිස් ලැයිස්තු අවස්ථාව හැසිරවීම</li>
                                <li>ප්‍රධානය ඉවත් කිරීම සඳහා විශේෂ අවස්ථාව (ස්ථානය 0)</li>
                                <li>සම්බන්ධ කිරීම සඳහා පෙර දර්ශකය පවත්වා ගැනීම</li>
                                <li>පරාසයෙන් පිටත ස්ථානය පරීක්ෂා කිරීම</li>
                                <li>මතක කාන්දු වැළැක්වීමට මතකය නිදහස් කිරීම</li>
                                <li>යාවත්කාලීන ප්‍රධාන දර්ශකය ආපසු යැවීම</li>
                            </ol>
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        d) Compare the advantages and disadvantages of using a doubly linked list versus a singly linked list for adding and removing elements frequently.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q2d-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q2d-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q2d-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Singly Linked List</th>
                                    <th>Doubly Linked List</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Node Structure</strong></td>
                                    <td>data + next pointer</td>
                                    <td>data + next + prev pointers</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory per Node</strong></td>
                                    <td>Less (1 pointer)</td>
                                    <td>More (2 pointers)</td>
                                </tr>
                                <tr>
                                    <td><strong>Traversal</strong></td>
                                    <td>Forward only</td>
                                    <td>Forward and backward</td>
                                </tr>
                                <tr>
                                    <td><strong>Insert at Beginning</strong></td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                </tr>
                                <tr>
                                    <td><strong>Insert at End</strong></td>
                                    <td>O(n) without tail pointer</td>
                                    <td>O(1) with tail pointer</td>
                                </tr>
                                <tr>
                                    <td><strong>Delete at Beginning</strong></td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                </tr>
                                <tr>
                                    <td><strong>Delete at End</strong></td>
                                    <td>O(n) - must traverse</td>
                                    <td>O(1) with tail pointer</td>
                                </tr>
                                <tr>
                                    <td><strong>Delete Given Node</strong></td>
                                    <td>O(n) - need previous node</td>
                                    <td>O(1) - have prev pointer</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>Advantages of Doubly Linked List:</h4>
                        <div class="definition-box">
                            <ol>
                                <li><strong>Bidirectional Traversal:</strong> Can move both forward and backward</li>
                                <li><strong>Efficient Deletion:</strong> O(1) deletion when node reference is given (don't need to find previous node)</li>
                                <li><strong>Easy Reverse Traversal:</strong> Can traverse from tail to head efficiently</li>
                                <li><strong>Better for certain algorithms:</strong> LRU cache, browser history, undo/redo functionality</li>
                                <li><strong>Efficient insertion before a node:</strong> Have direct access to previous node</li>
                            </ol>
                        </div>

                        <h4>Disadvantages of Doubly Linked List:</h4>
                        <div class="definition-box">
                            <ol>
                                <li><strong>More Memory:</strong> Extra pointer per node (significant for large lists)</li>
                                <li><strong>Complex Operations:</strong> More pointer manipulations required</li>
                                <li><strong>Higher Maintenance:</strong> Must update two pointers (next and prev) for every operation</li>
                                <li><strong>Cache Performance:</strong> Larger node size can reduce cache efficiency</li>
                            </ol>
                        </div>

                        <h4>Code Comparison:</h4>
                        <div class="code-block">
<pre><span class="comment">// Singly Linked List Node</span>
<span class="keyword">struct</span> <span class="type">SNode</span> {
    <span class="keyword">int</span> data;
    <span class="keyword">struct</span> <span class="type">SNode</span>* next;
};
<span class="comment">// Memory: 4 bytes (data) + 8 bytes (pointer) = 12 bytes</span>

<span class="comment">// Doubly Linked List Node</span>
<span class="keyword">struct</span> <span class="type">DNode</span> {
    <span class="keyword">int</span> data;
    <span class="keyword">struct</span> <span class="type">DNode</span>* next;
    <span class="keyword">struct</span> <span class="type">DNode</span>* prev;
};
<span class="comment">// Memory: 4 bytes (data) + 16 bytes (2 pointers) = 20 bytes</span>
<span class="comment">// 67% more memory per node!</span></pre>
                        </div>

                        <h4>When to Use Which:</h4>
                        <div class="example-box">
                            <strong>Use Singly Linked List when:</strong>
                            <ul>
                                <li>Memory is constrained</li>
                                <li>Only forward traversal needed</li>
                                <li>Simple stack or queue implementation</li>
                                <li>Insertions mostly at head</li>
                            </ul>

                            <strong>Use Doubly Linked List when:</strong>
                            <ul>
                                <li>Bidirectional traversal required</li>
                                <li>Frequent deletions with node reference</li>
                                <li>Need to insert before a given node</li>
                                <li>Implementing LRU cache, browser history</li>
                                <li>Memory overhead is acceptable</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q2d-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <h4>ද්විත්ව සම්බන්ධිත ලැයිස්තුවේ වාසි:</h4>
                        <div class="definition-box">
                            <ol>
                                <li><strong>ද්වි-දිශාත්මක ගමන්:</strong> ඉදිරියට සහ පසුපසට යා හැක</li>
                                <li><strong>කාර්යක්ෂම මකා දැමීම:</strong> නෝඩ් යොමුව දී ඇති විට O(1) මකා දැමීම</li>
                                <li><strong>පහසු ප්‍රතිලෝම ගමන්:</strong> වලිගයේ සිට ප්‍රධානය දක්වා කාර්යක්ෂමව ගමන් කළ හැක</li>
                                <li><strong>ඇතැම් ඇල්ගොරිතම සඳහා හොඳයි:</strong> LRU කැෂේ, බ්‍රවුසර ඉතිහාසය, අහෝසි/නැවත ක්‍රියාකාරිත්වය</li>
                            </ol>
                        </div>

                        <h4>ද්විත්ව සම්බන්ධිත ලැයිස්තුවේ අවාසි:</h4>
                        <div class="definition-box">
                            <ol>
                                <li><strong>වැඩි මතකය:</strong> නෝඩ් එකකට අමතර දර්ශකයක්</li>
                                <li><strong>සංකීර්ණ ක්‍රියාකාරකම්:</strong> වැඩි දර්ශක හැසිරවීම් අවශ්‍යයි</li>
                                <li><strong>ඉහළ නඩත්තුව:</strong> සෑම ක්‍රියාවක් සඳහාම දර්ශක දෙකක් යාවත්කාලීන කළ යුතුය</li>
                            </ol>
                        </div>

                        <h4>කවදා භාවිත කළ යුතුද:</h4>
                        <div class="example-box">
                            <strong>තනි සම්බන්ධිත ලැයිස්තුව භාවිතා කරන්න:</strong>
                            <ul>
                                <li>මතකය සීමිත වන විට</li>
                                <li>ඉදිරි ගමන් පමණක් අවශ්‍ය වන විට</li>
                            </ul>

                            <strong>ද්විත්ව සම්බන්ධිත ලැයිස්තුව භාවිතා කරන්න:</strong>
                            <ul>
                                <li>ද්වි-දිශාත්මක ගමන් අවශ්‍ය වන විට</li>
                                <li>නිරන්තර මකා දැමීම් සිදු වන විට</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="sub-question">
                    <div class="sub-question-label">
                        e) Suggest a change to the traditional linked list to make inserting at the end more efficient.
                        <span class="marks">(04 marks)</span>
                    </div>
                    
                    <button class="answer-toggle" onclick="toggleAnswer('q2e-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q2e-si')">සිංහල පිළිතුර</button>
                    
                    <div id="q2e-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        
                        <div class="definition-box">
                            <strong>Solution: Maintain a Tail Pointer</strong>
                            <p>Add an additional pointer that always points to the last node of the linked list. This changes insertion at the end from O(n) to O(1).</p>
                        </div>

                        <h4>Traditional Linked List (Without Tail Pointer):</h4>
                        <div class="code-block">
<pre><span class="keyword">struct</span> <span class="type">Node</span> {
    <span class="keyword">int</span> data;
    <span class="keyword">struct</span> <span class="type">Node</span>* next;
};

<span class="keyword">struct</span> <span class="type">Node</span>* head = <span class="keyword">NULL</span>;

<span class="comment">// Insert at end - O(n) complexity</span>
<span class="keyword">void</span> <span class="function">insertAtEnd</span>(<span class="keyword">int</span> value) {
    <span class="keyword">struct</span> <span class="type">Node</span>* newNode = <span class="function">createNode</span>(value);
    
    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) {
        head = newNode;
        <span class="keyword">return</span>;
    }
    
    <span class="comment">// Must traverse entire list - O(n)</span>
    <span class="keyword">struct</span> <span class="type">Node</span>* temp = head;
    <span class="keyword">while</span> (temp-&gt;next != <span class="keyword">NULL</span>) {
        temp = temp-&gt;next; <span class="comment">// Traverse to end</span>
    }
    temp-&gt;next = newNode;
}</pre>
                        </div>

                        <h4>Improved Linked List (With Tail Pointer):</h4>
                        <div class="code-block">
<pre><span class="keyword">struct</span> <span class="type">Node</span> {
    <span class="keyword">int</span> data;
    <span class="keyword">struct</span> <span class="type">Node</span>* next;
};

<span class="comment">// Maintain both head and tail pointers</span>
<span class="keyword">struct</span> <span class="type">Node</span>* head = <span class="keyword">NULL</span>;
<span class="keyword">struct</span> <span class="type">Node</span>* tail = <span class="keyword">NULL</span>; <span class="comment">// NEW: Tail pointer</span>

<span class="comment">// Insert at end - O(1) complexity!</span>
<span class="keyword">void</span> <span class="function">insertAtEnd</span>(<span class="keyword">int</span> value) {
    <span class="keyword">struct</span> <span class="type">Node</span>* newNode = <span class="function">createNode</span>(value);
    
    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) {
        <span class="comment">// Empty list</span>
        head = newNode;
        tail = newNode;
    } <span class="keyword">else</span> {
        <span class="comment">// Direct insertion at tail - O(1)</span>
        tail-&gt;next = newNode;
        tail = newNode;
    }
}

<span class="comment">// Delete from end - Still O(n) for singly linked list</span>
<span class="comment">// Would need doubly linked list for O(1) deletion at end</span>
<span class="keyword">void</span> <span class="function">deleteAtEnd</span>() {
    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) <span class="keyword">return</span>;
    
    <span class="keyword">if</span> (head == tail) {
        <span class="comment">// Only one node</span>
        <span class="function">free</span>(head);
        head = tail = <span class="keyword">NULL</span>;
        <span class="keyword">return</span>;
    }
    
    <span class="comment">// Must traverse to find second-last node - O(n)</span>
    <span class="keyword">struct</span> <span class="type">Node</span>* temp = head;
    <span class="keyword">while</span> (temp-&gt;next != tail) {
        temp = temp-&gt;next;
    }
    
    <span class="function">free</span>(tail);
    tail = temp;
    tail-&gt;next = <span class="keyword">NULL</span>;
}

<span class="comment">// Insert at beginning - Still O(1)</span>
<span class="keyword">void</span> <span class="function">insertAtBeginning</span>(<span class="keyword">int</span> value) {
    <span class="keyword">struct</span> <span class="type">Node</span>* newNode = <span class="function">createNode</span>(value);
    
    <span class="keyword">if</span> (head == <span class="keyword">NULL</span>) {
        head = newNode;
        tail = newNode;
    } <span class="keyword">else</span> {
        newNode-&gt;next = head;
        head = newNode;
    }
}</pre>
                        </div>

                        <h4>Complexity Comparison:</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Operation</th>
                                    <th>Without Tail</th>
                                    <th>With Tail</th>
                                    <th>Improvement</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Insert at End</strong></td>
                                    <td>O(n)</td>
                                    <td>O(1)</td>
                                    <td>✅ Huge improvement</td>
                                </tr>
                                <tr>
                                    <td><strong>Insert at Beginning</strong></td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                    <td>Same</td>
                                </tr>
                                <tr>
                                    <td><strong>Delete at End</strong></td>
                                    <td>O(n)</td>
                                    <td>O(n)</td>
                                    <td>No change (need doubly linked)</td>
                                </tr>
                                <tr>
                                    <td><strong>Access Last Element</strong></td>
                                    <td>O(n)</td>
                                    <td>O(1)</td>
                                    <td>✅ Huge improvement</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>Additional Benefits:</h4>
                        <div class="example-box">
                            <ol>
                                <li><strong>Queue Implementation:</strong> O(1) enqueue (insert at tail) and O(1) dequeue (remove from head)</li>
                                <li><strong>Append Operations:</strong> Efficient for building lists incrementally</li>
                                <li><strong>Last Element Access:</strong> Direct access to last element without traversal</li>
                            </ol>
                        </div>

                        <h4>Trade-offs:</h4>
                        <div class="note-box">
                            <strong>Advantages:</strong>
                            <ul>
                                <li>O(1) insertion at end</li>
                                <li>O(1) access to last element</li>
                                <li>Perfect for queue implementation</li>
                            </ul>
                            
                            <strong>Disadvantages:</strong>
                            <ul>
                                <li>Extra pointer to maintain (8 bytes)</li>
                                <li>More complex code (must update tail pointer)</li>
                                <li>Still O(n) for deletion at end (would need doubly linked list for O(1))</li>
                            </ul>
                        </div>
                    </div>

                    <div id="q2e-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        
                        <div class="definition-box">
                            <strong>විසඳුම: වලිග දර්ශකයක් පවත්වා ගැනීම</strong>
                            <p>සම්බන්ධිත ලැයිස්තුවේ අවසාන නෝඩ් එක වෙත සැමවිටම යොමු වන අමතර දර්ශකයක් එක් කරන්න. මෙය අවසානයේ ඇතුළත් කිරීම O(n) සිට O(1) දක්වා වෙනස් කරයි.</p>
                        </div>

                        <h4>සංකීර්ණත්ව සංසන්දනය:</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>ක්‍රියාව</th>
                                    <th>වලිගයක් නැතිව</th>
                                    <th>වලිගයක් සමඟ</th>
                                    <th>වැඩිදියුණු කිරීම</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>අවසානයේ ඇතුළත් කිරීම</strong></td>
                                    <td>O(n)</td>
                                    <td>O(1)</td>
                                    <td>✅ විශාල වැඩිදියුණු කිරීමක්</td>
                                </tr>
                                <tr>
                                    <td><strong>ආරම්භයේ ඇතුළත් කිරීම</strong></td>
                                    <td>O(1)</td>
                                    <td>O(1)</td>
                                    <td>සමානයි</td>
                                </tr>
                                <tr>
                                    <td><strong>අවසාන මූලද්‍රව්‍ය ප්‍රවේශය</strong></td>
                                    <td>O(n)</td>
                                    <td>O(1)</td>
                                    <td>✅ විශාල වැඩිදියුණු කිරීමක්</td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>අමතර ප්‍රතිලාභ:</h4>
                        <div class="example-box">
                            <ol>
                                <li><strong>පෝලිම ක්‍රියාත්මක කිරීම:</strong> O(1) enqueue සහ O(1) dequeue</li>
                                <li><strong>එකතු කිරීමේ ක්‍රියාකාරකම්:</strong> වර්ධක ලැයිස්තු ගොඩනැගීම සඳහා කාර්යක්ෂමයි</li>
                                <li><strong>අවසාන මූලද්‍රව්‍ය ප්‍රවේශය:</strong> ගමන් නොකර අවසාන මූලද්‍රව්‍යය වෙත සෘජු ප්‍රවේශය</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <!-- QUESTION 3 -->
            <div class="question-block">
                <div class="question-number">Question 3</div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        a) Differentiate between a Stack (LIFO) and a Queue (FIFO) data structure. Provide one real-world example for each.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q3a-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q3a-si')">සිංහල පිළිතුර</button>
                    <div id="q3a-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Stack</th>
                                    <th>Queue</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Principle</strong></td>
                                    <td>LIFO (Last-In, First-Out)</td>
                                    <td>FIFO (First-In, First-Out)</td>
                                </tr>
                                <tr>
                                    <td><strong>Insertion Operation</strong></td>
                                    <td>Push (adds to top)</td>
                                    <td>Enqueue (adds to rear/end)</td>
                                </tr>
                                <tr>
                                    <td><strong>Deletion Operation</strong></td>
                                    <td>Pop (removes from top)</td>
                                    <td>Dequeue (removes from front)</td>
                                </tr>
                                <tr>
                                    <td><strong>Pointers</strong></td>
                                    <td>One pointer: `top`</td>
                                    <td>Two pointers: `front` and `rear`</td>
                                </tr>
                                <tr>
                                    <td><strong>Real-World Example</strong></td>
                                    <td>Stack of plates, Browser history (Back button)</td>
                                    <td>Queue at a ticket counter, Printer job queue</td>
                                </tr>
                            </tbody>
                        </table>
            
                        <div class="example-box">
                            <strong>Stack (LIFO) Example: Browser History</strong>
                            <p>When you visit websites, each new site is "pushed" onto the top of the history stack. When you press the "Back" button, the most recent site (the one at the top) is "popped" off, and you are taken to the previous page. The last site you visited is the first one you go back to.</p>
                        </div>
            
                        <div class="example-box">
                            <strong>Queue (FIFO) Example: Printer Queue</strong>
                            <p>When you send multiple documents to a printer, they are added to a queue. The first document you sent (First-In) is the first one to be printed (First-Out). Documents are processed in the order they were received.</p>
                        </div>
                    </div>
                    <div id="q3a-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>අංගය</th>
                                    <th>Stack (අට්ටි)</th>
                                    <th>Queue (පෝලිම්)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>මූලධර්මය</strong></td>
                                    <td>LIFO (අවසානයට ඇතුල්වූ දේ, පලමුවෙන් පිටවීම)</td>
                                    <td>FIFO (පලමුවෙන් ඇතුල්වූ දේ, පලමුවෙන් පිටවීම)</td>
                                </tr>
                                <tr>
                                    <td><strong>ඇතුල් කිරීම</strong></td>
                                    <td>Push (ඉහලට එක් කිරීම)</td>
                                    <td>Enqueue (පිටුපසට එක් කිරීම)</td>
                                </tr>
                                <tr>
                                    <td><strong>ඉවත් කිරීම</strong></td>
                                    <td>Pop (ඉහලින් ඉවත් කිරීම)</td>
                                    <td>Dequeue (ඉදිරියෙන් ඉවත් කිරීම)</td>
                                </tr>
                                <tr>
                                    <td><strong>සැබෑ ලෝක උදාහරණ</strong></td>
                                    <td>පිඟන් අට්ටිය, වෙබ් බ්‍රව්සරයේ Back බොත්තම</td>
                                    <td>ප්‍රවේශ පත්‍ර කවුන්ටරයක පෝලිම, මුද්‍රණ යන්ත්‍රයක කාර්ය පෝලිම</td>
                                </tr>
                            </tbody>
                        </table>
            
                        <div class="example-box">
                            <strong>Stack (LIFO) උදාහරණය: බ්‍රව්සර් ඉතිහාසය</strong>
                            <p>ඔබ වෙබ් අඩවි වලට පිවිසෙන විට, සෑම නව අඩවියක්ම ඉතිහාස අට්ටියේ ඉහළට "push" කරනු ලැබේ. ඔබ "Back" බොත්තම එබූ විට, නවතම අඩවිය (ඉහළින්ම ඇති එක) "pop" කරනු ලබන අතර, ඔබව පෙර පිටුවට ගෙන යයි.</p>
                        </div>
            
                        <div class="example-box">
                            <strong>Queue (FIFO) උදාහරණය: මුද්‍රණ යන්ත්‍ර පෝලිම</strong>
                            <p>ඔබ මුද්‍රණ යන්ත්‍රයකට ලේඛන කිහිපයක් යවන විට, ඒවා පෝලිමකට එකතු වේ. ඔබ මුලින්ම යැවූ ලේඛනය (First-In) මුලින්ම මුද්‍රණය වේ (First-Out).</p>
                        </div>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        b) Write C/C++ code to implement a stack using an array, including `push`, `pop`, and `peek` functions.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q3b-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q3b-si')">සිංහල පිළිතුර</button>
                    <div id="q3b-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="code-block">
<pre><span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#define</span> MAX_SIZE <span class="number">100</span>

<span class="keyword">class</span> <span class="type">Stack</span> {
<span class="keyword">private</span>:
    <span class="keyword">int</span> arr[MAX_SIZE];
    <span class="keyword">int</span> top;

<span class="keyword">public</span>:
    <span class="function">Stack</span>() {
        top = -<span class="number">1</span>; <span class="comment">// Initialize stack as empty</span>
    }

    <span class="comment">// Push operation: Add an element to the top</span>
    <span class="keyword">void</span> <span class="function">push</span>(<span class="keyword">int</span> value) {
        <span class="keyword">if</span> (top >= MAX_SIZE - <span class="number">1</span>) {
            std::cout &lt;&lt; <span class="string">"Stack Overflow\n"</span>;
            <span class="keyword">return</span>;
        }
        arr[++top] = value;
    }

    <span class="comment">// Pop operation: Remove and return the top element</span>
    <span class="keyword">int</span> <span class="function">pop</span>() {
        <span class="keyword">if</span> (top &lt; <span class="number">0</span>) {
            std::cout &lt;&lt; <span class="string">"Stack Underflow\n"</span>;
            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// Return an indicator for error</span>
        }
        <span class="keyword">return</span> arr[top--];
    }

    <span class="comment">// Peek operation: Return the top element without removing it</span>
    <span class="keyword">int</span> <span class="function">peek</span>() {
        <span class="keyword">if</span> (top &lt; <span class="number">0</span>) {
            std::cout &lt;&lt; <span class="string">"Stack is empty\n"</span>;
            <span class="keyword">return</span> -<span class="number">1</span>;
        }
        <span class="keyword">return</span> arr[top];
    }

    <span class="comment">// Check if the stack is empty</span>
    <span class="keyword">bool</span> <span class="function">isEmpty</span>() {
        <span class="keyword">return</span> (top &lt; <span class="number">0</span>);
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="type">Stack</span> myStack;
    myStack.<span class="function">push</span>(<span class="number">10</span>);
    myStack.<span class="function">push</span>(<span class="number">20</span>);
    myStack.<span class="function">push</span>(<span class="number">30</span>);

    std::cout &lt;&lt; myStack.<span class="function">peek</span>() &lt;&lt; <span class="string">" is at the top\n"</span>; <span class="comment">// 30</span>
    std::cout &lt;&lt; myStack.<span class="function">pop</span>() &lt;&lt; <span class="string">" popped from stack\n"</span>; <span class="comment">// 30</span>
    std::cout &lt;&lt; myStack.<span class="function">peek</span>() &lt;&lt; <span class="string">" is now at the top\n"</span>; <span class="comment">// 20</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre>
                        </div>
                        <div class="note-box">
                            <strong>Complexity Analysis:</strong>
                            <ul>
                                <li><strong>push():</strong> O(1)</li>
                                <li><strong>pop():</strong> O(1)</li>
                                <li><strong>peek():</strong> O(1)</li>
                            </ul>
                            All operations are constant time because they involve direct access via the `top` index.
                        </div>
                    </div>
                    <div id="q3b-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <p>ඉහත C++ කේතය අරාවක් (array) භාවිතයෙන් stack එකක් ක්‍රියාත්මක කරන ආකාරය පෙන්වයි. එයට `push` (මූලද්‍රව්‍යයක් එක් කිරීම), `pop` (මූලද්‍රව්‍යයක් ඉවත් කිරීම), සහ `peek` (ඉහළම මූලද්‍රව්‍යය බැලීම) යන ශ්‍රිත ඇතුළත් වේ.</p>
                        <div class="note-box">
                            <strong>සංකීර්ණතා විශ්ලේෂණය:</strong>
                            <ul>
                                <li><strong>push():</strong> O(1)</li>
                                <li><strong>pop():</strong> O(1)</li>
                                <li><strong>peek():</strong> O(1)</li>
                            </ul>
                            `top` දර්ශකය හරහා සෘජු ප්‍රවේශය සිදුවන බැවින් සියලුම මෙහෙයුම් සඳහා නියත කාලයක් ගතවේ.
                        </div>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        c) Explain why a circular queue is considered more efficient than a linear queue implemented with an array.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q3c-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q3c-si')">සිංහල පිළිතුර</button>
                    <div id="q3c-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="definition-box">
                            A circular queue is more efficient than a linear queue primarily because it makes <span class="highlight">better use of the array's memory space</span>.
                        </div>
                        <h4>Problem with Linear Queue:</h4>
                        <p>In a simple linear queue using an array, elements are always added at the `rear` and removed from the `front`. After several dequeue operations, the space at the beginning of the array becomes empty and unusable, even if the queue is not full. The `rear` pointer can reach the end of the array, causing a "false" full condition, while empty slots exist at the front.</p>
                        <div class="code-block">
<pre><span class="comment">// Linear Queue State after some operations</span>
// Capacity = 5, front = 3, rear = 4
[ , , , item4, item5 ]
  ↑--- Unused Space ---↑
<span class="comment">// Queue appears full, cannot add more, but 3 slots are wasted.</span>
</pre>
                        </div>
            
                        <h4>Solution with Circular Queue:</h4>
                        <p>A circular queue overcomes this limitation by treating the array as circular. When the `rear` pointer reaches the end of the array, it "wraps around" to the beginning, provided there is empty space. This is achieved using the modulo operator.</p>
                        <p class="formula">rear = (rear + 1) % CAPACITY</p>
                        <p class="formula">front = (front + 1) % CAPACITY</p>
            
                        <div class="code-block">
<pre><span class="comment">// Circular Queue State</span>
// Capacity = 5, front = 3, rear = 1
[ item6, item7, , item4, item5 ]
         ↑      ↑      ↑
        rear  Unused  front
<span class="comment">// The queue efficiently uses the wrapped-around space.</span>
</pre>
                        </div>
            
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Linear Queue</th>
                                    <th>Circular Queue</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Space Utilization</strong></td>
                                    <td>Inefficient; leads to wasted space.</td>
                                    <td>Efficient; reuses empty slots.</td>
                                </tr>
                                <tr>
                                    <td><strong>"Queue Full" Condition</strong></td>
                                    <td>`rear == MAX_SIZE - 1` (Can be false)</td>
                                    <td>`(rear + 1) % MAX_SIZE == front` (Accurate)</td>
                                </tr>
                                <tr>
                                    <td><strong>Resetting Pointers</strong></td>
                                    <td>Requires shifting all elements (O(n)) to reuse space.</td>
                                    <td>No shifting needed; pointers wrap around (O(1)).</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div id="q3c-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <div class="definition-box">
                            චක්‍රීය පෝලිමක් (circular queue) රේඛීය පෝලිමකට (linear queue) වඩා කාර්යක්ෂම වීමට ප්‍රධාන හේතුව එය <span class="highlight">අරාවේ මතක අවකාශය වඩාත් හොඳින් භාවිතා කිරීමයි</span>.
                        </div>
                        <h4>රේඛීය පෝලිමේ ගැටලුව:</h4>
                        <p>අරාවක් භාවිතා කරන සාමාන්‍ය රේඛීය පෝලිමක, මූලද්‍රව්‍ය `rear` (පිටුපස) වෙතින් එකතු කර `front` (ඉදිරිපස) වෙතින් ඉවත් කරනු ලැබේ. කිහිප වරක් dequeue කිරීමෙන් පසු, අරාවේ ඉදිරිපස කොටස හිස් වන අතර, පෝලිම සම්පූර්ණයෙන් පිරී නොතිබුණත් එම ඉඩ නැවත භාවිතා කළ නොහැක. `rear` දර්ශකය අරාවේ අවසානයට ළඟා වූ විට, ඉදිරිපස හිස් ඉඩ තිබුණද, පෝලිම "ව්‍යාජ ලෙස පිරී" ඇති බවක් පෙනේ.</p>
            
                        <h4>චක්‍රීය පෝලිමෙන් ලැබෙන විසඳුම:</h4>
                        <p>චක්‍රීය පෝලිම මෙම සීමාව මඟහරවා ගන්නේ අරාව චක්‍රාකාර එකක් ලෙස සලකමිනි. `rear` දර්ශකය අරාවේ අවසානයට ළඟා වූ විට, හිස් ඉඩක් ඇත්නම් එය නැවත ආරම්භයට "වටේට පැමිණේ". මෙය මොඩියුලෝ ක්‍රියාකරු (%) භාවිතයෙන් සිදු කරයි.</p>
                        <p class="formula">rear = (rear + 1) % CAPACITY</p>
            
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>ලක්ෂණය</th>
                                    <th>රේඛීය පෝලිම</th>
                                    <th>චක්‍රීය පෝලිම</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>අවකාශ භාවිතය</strong></td>
                                    <td>අකාර්යක්ෂමයි; ඉඩ අපතේ යයි.</td>
                                    <td>කාර්යක්ෂමයි; හිස් තැන් නැවත භාවිතා කරයි.</td>
                                </tr>
                                <tr>
                                    <td><strong>නැවත සැකසීම</strong></td>
                                    <td>ඉඩ නැවත භාවිතා කිරීමට මූලද්‍රව්‍ය මාරු කිරීම (O(n)) අවශ්‍ය වේ.</td>
                                    <td>මාරු කිරීම අවශ්‍ය නැත; දර්ශක චක්‍රාකාරව ගමන් කරයි (O(1)).</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        d) Describe the steps to convert the infix expression `(A + B) * C - (D / E)` to a postfix expression using a stack.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q3d-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q3d-si')">සිංහල පිළිතුර</button>
                    <div id="q3d-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <p>We use a stack to hold operators and parentheses. The algorithm scans the infix expression from left to right.</p>
                        <div class="definition-box">
                            <strong>Operator Precedence:</strong> `*`, `/` (high), `+`, `-` (low).
                        </div>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Token Scanned</th>
                                    <th>Stack</th>
                                    <th>Postfix Expression</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>(</td>
                                    <td>(</td>
                                    <td></td>
                                    <td>Push `(` onto stack.</td>
                                </tr>
                                <tr>
                                    <td>A</td>
                                    <td>(</td>
                                    <td>A</td>
                                    <td>Operand, append to output.</td>
                                </tr>
                                <tr>
                                    <td>+</td>
                                    <td>(+</td>
                                    <td>A</td>
                                    <td>Push `+` onto stack.</td>
                                </tr>
                                <tr>
                                    <td>B</td>
                                    <td>(+</td>
                                    <td>A B</td>
                                    <td>Operand, append to output.</td>
                                </tr>
                                <tr>
                                    <td>)</td>
                                    <td></td>
                                    <td>A B +</td>
                                    <td>Pop from stack and append to output until `(` is found. Pop `(`.</td>
                                </tr>
                                <tr>
                                    <td>*</td>
                                    <td>*</td>
                                    <td>A B +</td>
                                    <td>Push `*` onto stack.</td>
                                </tr>
                                <tr>
                                    <td>C</td>
                                    <td>*</td>
                                    <td>A B + C</td>
                                    <td>Operand, append to output.</td>
                                </tr>
                                <tr>
                                    <td>-</td>
                                    <td>-</td>
                                    <td>A B + C *</td>
                                    <td>Stack top `*` has higher precedence. Pop `*`, push `-`.</td>
                                </tr>
                                <tr>
                                    <td>(</td>
                                    <td>-(</td>
                                    <td>A B + C *</td>
                                    <td>Push `(` onto stack.</td>
                                </tr>
                                <tr>
                                    <td>D</td>
                                    <td>-(</td>
                                    <td>A B + C * D</td>
                                    <td>Operand, append to output.</td>
                                </tr>
                                <tr>
                                    <td>/</td>
                                    <td>-(/</td>
                                    <td>A B + C * D</td>
                                    <td>Push `/` onto stack.</td>
                                </tr>
                                <tr>
                                    <td>E</td>
                                    <td>-(/</td>
                                    <td>A B + C * D E</td>
                                    <td>Operand, append to output.</td>
                                </tr>
                                <tr>
                                    <td>)</td>
                                    <td>-</td>
                                    <td>A B + C * D E /</td>
                                    <td>Pop `/` until `(` is found. Pop `(`.</td>
                                </tr>
                                <tr>
                                    <td><em>End</em></td>
                                    <td></td>
                                    <td>A B + C * D E / -</td>
                                    <td>End of expression. Pop remaining operators (`-`).</td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="note-box">
                            <strong>Final Postfix Expression:</strong> <span class="formula">A B + C * D E / -</span>
                        </div>
                    </div>
                    <div id="q3d-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <p>අපි ක්‍රියාකරුවන් (operators) සහ වරහන් තබා ගැනීමට අට්ටියක් (stack) භාවිතා කරමු. ඇල්ගොරිතමය වමේ සිට දකුණට infix ප්‍රකාශනය පරිලෝකනය කරයි.</p>
                        <div class="definition-box">
                            <strong>ක්‍රියාකරු ප්‍රමුඛතාවය:</strong> `*`, `/` (ඉහළ), `+`, `-` (අඩු).
                        </div>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>ස්කෑන් කළ ටෝකනය</th>
                                    <th>Stack (අට්ටිය)</th>
                                    <th>Postfix ප්‍රකාශනය</th>
                                    <th>ක්‍රියාව</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>(</td>
                                    <td>(</td>
                                    <td></td>
                                    <td>`(` අට්ටියට දමන්න.</td>
                                </tr>
                                <tr>
                                    <td>A</td>
                                    <td>(</td>
                                    <td>A</td>
                                    <td>Operand, ප්‍රතිදානයට එක් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>+</td>
                                    <td>(+</td>
                                    <td>A</td>
                                    <td>`+` අට්ටියට දමන්න.</td>
                                </tr>
                                <tr>
                                    <td>B</td>
                                    <td>(+</td>
                                    <td>A B</td>
                                    <td>Operand, ප්‍රතිදානයට එක් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>)</td>
                                    <td></td>
                                    <td>A B +</td>
                                    <td>`(` හමුවන තුරු අට්ටියෙන් pop කර ප්‍රතිදානයට එක් කරන්න. `(` ඉවත් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>*</td>
                                    <td>*</td>
                                    <td>A B +</td>
                                    <td>`*` අට්ටියට දමන්න.</td>
                                </tr>
                                <tr>
                                    <td>C</td>
                                    <td>*</td>
                                    <td>A B + C</td>
                                    <td>Operand, ප්‍රතිදානයට එක් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>-</td>
                                    <td>-</td>
                                    <td>A B + C *</td>
                                    <td>අට්ටියේ ඉහල ඇති `*` ට වැඩි ප්‍රමුඛතාවයක් ඇත. `*` pop කර, `-` push කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>(</td>
                                    <td>-(</td>
                                    <td>A B + C *</td>
                                    <td>`(` අට්ටියට දමන්න.</td>
                                </tr>
                                <tr>
                                    <td>D</td>
                                    <td>-(</td>
                                    <td>A B + C * D</td>
                                    <td>Operand, ප්‍රතිදානයට එක් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>/</td>
                                    <td>-(/</td>
                                    <td>A B + C * D</td>
                                    <td>`/` අට්ටියට දමන්න.</td>
                                </tr>
                                <tr>
                                    <td>E</td>
                                    <td>-(/</td>
                                    <td>A B + C * D E</td>
                                    <td>Operand, ප්‍රතිදානයට එක් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td>)</td>
                                    <td>-</td>
                                    <td>A B + C * D E /</td>
                                    <td>`(` හමුවන තුරු `/` pop කරන්න. `(` ඉවත් කරන්න.</td>
                                </tr>
                                <tr>
                                    <td><em>අවසානය</em></td>
                                    <td></td>
                                    <td>A B + C * D E / -</td>
                                    <td>ප්‍රකාශනයේ අවසානය. ඉතිරි ක්‍රියාකරුවන් (`-`) pop කරන්න.</td>
                                </tr>
                            </tbody>
                        </table>
                         <div class="note-box">
                            <strong>අවසාන Postfix ප්‍රකාශනය:</strong> <span class="formula">A B + C * D E / -</span>
                        </div>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        e) What is a Priority Queue? Name two common ways to implement it and list one of its applications.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q3e-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q3e-si')">සිංහල පිළිතුර</button>
                    <div id="q3e-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="definition-box">
                            <strong>Priority Queue Definition:</strong>
                            <p>A Priority Queue is an abstract data type similar to a regular queue, but where each element has an associated "priority". Elements with higher priority are served before elements with lower priority. If two elements have the same priority, they are served based on their order in the queue (FIFO).</p>
                        </div>
            
                        <h4>Common Implementations:</h4>
                        <ol>
                            <li>
                                <strong>Heap (Binary Heap):</strong> This is the most common and efficient way. A max-heap can be used to quickly access the highest-priority item in O(1) time. Insertion (enqueue) and deletion (dequeue) take O(log n) time.
                            </li>
                            <li>
                                <strong>Unsorted Array/List:</strong>
                                <ul>
                                    <li><strong>Enqueue:</strong> Add the new element to the end. This is O(1).</li>
                                    <li><strong>Dequeue:</strong> Search the entire array to find the highest-priority element. This is O(n).</li>
                                </ul>
                            </li>
                            <li>
                                <strong>Sorted Array/List:</strong>
                                 <ul>
                                    <li><strong>Enqueue:</strong> Find the correct position based on priority and insert the element. This is O(n).</li>
                                    <li><strong>Dequeue:</strong> Remove the element from the front (or back, depending on sort order). This is O(1).</li>
                                </ul>
                            </li>
                        </ol>
            
                        <table class="comparison-table">
                           <thead>
                               <tr><th>Implementation</th><th>Enqueue (Insert)</th><th>Dequeue (Remove Max)</th><th>Peek (Find Max)</th></tr>
                           </thead>
                           <tbody>
                               <tr><td><strong>Heap</strong></td><td>O(log n)</td><td>O(log n)</td><td>O(1)</td></tr>
                               <tr><td><strong>Unsorted Array</strong></td><td>O(1)</td><td>O(n)</td><td>O(n)</td></tr>
                               <tr><td><strong>Sorted Array</strong></td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr>
                           </tbody>
                        </table>
            
                        <h4>Applications:</h4>
                        <div class="example-box">
                            One primary application is in <strong>Dijkstra's shortest path algorithm</strong> for graphs. A priority queue (specifically a min-priority queue) is used to efficiently select the unvisited vertex with the smallest distance from the source at each step.
                            <br><br><strong>Other Applications:</strong>
                            <ul>
                                <li>CPU process scheduling in operating systems.</li>
                                <li>Huffman coding for data compression.</li>
                                <li>A* search algorithm.</li>
                            </ul>
                        </div>
                    </div>
                    <div id="q3e-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <div class="definition-box">
                            <strong>ප්‍රමුඛතා පෝලිම (Priority Queue) යනු කුමක්ද:</strong>
                            <p>ප්‍රමුඛතා පෝලිමක් යනු සාමාන්‍ය පෝලිමකට සමාන වන නමුත්, එහි සෑම මූලද්‍රව්‍යයකටම "ප්‍රමුඛතාවයක්" සම්බන්ධ කර ඇති දත්ත ව්‍යුහයකි. අඩු ප්‍රමුඛතා ඇති මූලද්‍රව්‍යවලට පෙර ඉහළ ප්‍රමුඛතා ඇති මූලද්‍රව්‍ය සකසනු ලැබේ. මූලද්‍රව්‍ය දෙකක එකම ප්‍රමුඛතාවය තිබේ නම්, ඒවා පෝලිමේ ඇති අනුපිළිවෙල (FIFO) මත පදනම්ව සකසනු ලැබේ.</p>
                        </div>
            
                        <h4>ක්‍රියාත්මක කිරීමේ ක්‍රම:</h4>
                        <ol>
                            <li>
                                <strong>Heap (ගොඩ):</strong> මෙය වඩාත්ම කාර්යක්ෂම ක්‍රමයයි. Max-heap එකක් භාවිතයෙන් ඉහළම ප්‍රමුඛතා අයිතමය O(1) කාලයකින් ලබාගත හැක. ඇතුළත් කිරීම (enqueue) සහ ඉවත් කිරීම (dequeue) සඳහා O(log n) කාලයක් ගතවේ.
                            </li>
                            <li>
                                <strong>නොවර්ග කළ අරාව/ලැයිස්තුව:</strong>
                                <ul>
                                    <li><strong>Enqueue:</strong> O(1) - අවසානයට එක් කිරීම.</li>
                                    <li><strong>Dequeue:</strong> O(n) - ඉහළම ප්‍රමුඛතාවය සෙවීම.</li>
                                </ul>
                            </li>
                        </ol>
            
                        <h4>යෙදුම් (Applications):</h4>
                        <div class="example-box">
                            ප්‍රධාන යෙදුමක් වන්නේ ප්‍රස්තාර සඳහා වන <strong>ඩිජ්ක්ස්ට්‍රාගේ කෙටිම මාර්ග ඇල්ගොරිතමයේදීය</strong>. එක් එක් පියවරේදී මූලයෙන් කුඩාම දුර ඇති, තවමත් නොදුටු ශීර්ෂය කාර්යක්ෂමව තෝරා ගැනීමට ප්‍රමුඛතා පෝලිමක් (min-priority queue) භාවිතා කරයි.
                            <br><br><strong>වෙනත් යෙදුම්:</strong>
                            <ul>
                                <li>මෙහෙයුම් පද්ධතිවල CPU ක්‍රියාවලි කාලසටහන්ගත කිරීම.</li>
                                <li>දත්ත සම්පීඩනය සඳහා හෆ්මන් කේතීකරණය.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- QUESTION 4 -->
            <div class="question-block">
                <div class="question-number">Question 4</div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        a) Explain the principle behind Binary Search. What is the main prerequisite for this algorithm to work?
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q4a-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q4a-si')">සිංහල පිළිතුර</button>
                    <div id="q4a-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="definition-box">
                            <strong>Principle of Binary Search:</strong><br>
                            Binary Search is a "divide and conquer" search algorithm. It works by repeatedly dividing the search interval in half. It compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found or the interval is empty.
                        </div>
            
                        <h4>Steps:</h4>
                        <ol>
                            <li>Compare the target value with the middle element of the sorted array.</li>
                            <li>If the target value matches the middle element, its position is returned.</li>
                            <li>If the target value is less than the middle element, narrow the search to the lower half of the array.</li>
                            <li>If the target value is greater than the middle element, narrow the search to the upper half of the array.</li>
                            <li>Repeat the process until the value is found or the subarray size becomes zero.</li>
                        </ol>
            
                        <div class="note-box">
                            <strong>Main Prerequisite:</strong><br>
                            The most crucial prerequisite for Binary Search is that the <span class="highlight">data collection (e.g., array) must be sorted</span>. If the array is not sorted, the core assumption that allows us to eliminate half of the dataset at each step is invalid, and the algorithm will not produce the correct result.
                        </div>
            
                        <div class="example-box">
                            <strong>Time Complexity:</strong> O(log n) - because it halves the search space in each iteration.
                        </div>
                    </div>
                    <div id="q4a-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <div class="definition-box">
                            <strong>ද්විමය සෙවීමේ (Binary Search) මූලධර්මය:</strong><br>
                            Binary Search යනු "බෙදා ජය ගැනීමේ" (divide and conquer) සෙවුම් ඇල්ගොරිතමයකි. එය ක්‍රියා කරන්නේ සෙවුම් පරතරය නැවත නැවතත් අඩකින් බෙදීමෙනි. එය ඉලක්කගත අගය අරාවේ මැද මූලද්‍රව්‍යය සමඟ සංසන්දනය කරයි. ඒවා සමාන නොවේ නම්, ඉලක්කය පැවතිය නොහැකි අර්ධය ඉවත් කරනු ලබන අතර, ඉතිරි අර්ධය මත සෙවීම දිගටම කරගෙන යයි. මෙම ක්‍රියාවලිය ඉලක්කගත අගය සොයා ගන්නා තෙක් හෝ පරතරය හිස් වන තෙක් නැවත නැවතත් සිදු වේ.
                        </div>
            
                        <div class="note-box">
                            <strong>ප්‍රධාන පූර්ව අවශ්‍යතාවය:</strong><br>
                            Binary Search සඳහා ඇති වැදගත්ම පූර්ව අවශ්‍යතාවය නම් <span class="highlight">දත්ත එකතුව (උදා: අරාව) වර්ගීකරණය කර (sorted) තිබීමයි</span>. අරාව වර්ගීකරණය කර නොමැති නම්, එක් එක් පියවරේදී දත්ත කට්ටලයෙන් අඩක් ඉවත් කිරීමට ඉඩ සලසන මූලික උපකල්පනය වලංගු නොවන අතර, ඇල්ගොරිතමය නිවැරදි ප්‍රතිඵලයක් ලබා නොදේ.
                        </div>
            
                        <div class="example-box">
                            <strong>කාල සංකීර්ණත්වය:</strong> O(log n) - එය සෑම පුනරාවර්තනයකදීම සෙවුම් අවකාශය අඩකින් අඩු කරන බැවිනි.
                        </div>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        b) Compare and contrast Quicksort and Mergesort algorithms based on their time complexity, space complexity, and stability.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q4b-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q4b-si')">සිංහල පිළිතුර</button>
                    <div id="q4b-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Quicksort</th>
                                    <th>Mergesort</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Time Complexity (Avg)</strong></td>
                                    <td>O(n log n)</td>
                                    <td>O(n log n)</td>
                                </tr>
                                <tr>
                                    <td><strong>Time Complexity (Worst)</strong></td>
                                    <td>O(n²) - (e.g., with a sorted array and bad pivot selection)</td>
                                    <td>O(n log n) - (Consistent performance)</td>
                                </tr>
                                <tr>
                                    <td><strong>Space Complexity</strong></td>
                                    <td>O(log n) - (In-place sorting, uses recursion stack)</td>
                                    <td>O(n) - (Requires temporary arrays for merging)</td>
                                </tr>
                                <tr>
                                    <td><strong>Stability</strong></td>
                                    <td>Not Stable - (Relative order of equal elements may change)</td>
                                    <td>Stable - (Relative order of equal elements is preserved)</td>
                                </tr>
                                <tr>
                                    <td><strong>Method</strong></td>
                                    <td>Divide and Conquer (Partitioning around a pivot)</td>
                                    <td>Divide and Conquer (Dividing and Merging)</td>
                                </tr>
                                <tr>
                                    <td><strong>Best For</strong></td>
                                    <td>Internal sorting (arrays) where space is a concern. Generally faster in practice.</td>
                                    <td>External sorting (linked lists, large datasets) and when stability is required.</td>
                                </tr>
                            </tbody>
                        </table>
                        <div class="note-box">
                            <strong>Summary:</strong> Quicksort is often faster in practice and uses less space, making it ideal for sorting arrays in memory. However, its O(n²) worst-case performance can be a risk. Mergesort provides guaranteed O(n log n) performance and is stable, but requires extra memory, making it suitable for linked lists and external sorting.
                        </div>
                    </div>
                    <div id="q4b-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>අංගය</th>
                                    <th>Quicksort</th>
                                    <th>Mergesort</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>කාල සංකීර්ණත්වය (සාමාන්‍ය)</strong></td>
                                    <td>O(n log n)</td>
                                    <td>O(n log n)</td>
                                </tr>
                                <tr>
                                    <td><strong>කාල සංකීර්ණත්වය (නරකම)</strong></td>
                                    <td>O(n²) - (වර්ග කළ අරාවක් සහ නරක pivot තේරීමක් සමඟ)</td>
                                    <td>O(n log n) - (ස්ථාවර ක්‍රියාකාරිත්වය)</td>
                                </tr>
                                <tr>
                                    <td><strong>අවකාශ සංකීර්ණත්වය</strong></td>
                                    <td>O(log n) - (In-place, පුනරාවර්තන stackය භාවිතා කරයි)</td>
                                    <td>O(n) - (ඒකාබද්ධ කිරීමට තාවකාලික අරා අවශ්‍ය වේ)</td>
                                </tr>
                                <tr>
                                    <td><strong>ස්ථායීතාවය (Stability)</strong></td>
                                    <td>ස්ථායී නොවේ - (සමාන මූලද්‍රව්‍යවල සාපේක්ෂ අනුපිළිවෙල වෙනස් විය හැක)</td>
                                    <td>ස්ථායී වේ - (සමාන මූලද්‍රව්‍යවල සාපේක්ෂ අනුපිළිවෙල ආරක්ෂා වේ)</td>
                                </tr>
                                <tr>
                                    <td><strong>හොඳම භාවිතය</strong></td>
                                    <td>අභ්‍යන්තර වර්ගීකරණය (arrays) සඳහා, ඉඩකඩ සීමිත විට.</td>
                                    <td>බාහිර වර්ගීකරණය (linked lists, විශාල දත්ත) සහ ස්ථායීතාවය අවශ්‍ය විට.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        c) What is a "stable" sorting algorithm? Provide an example of a stable and an unstable sorting algorithm.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q4c-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q4c-si')">සිංහල පිළිතුර</button>
                    <div id="q4c-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="definition-box">
                            <strong>Stable Sorting Algorithm:</strong>
                            <p>A sorting algorithm is considered "stable" if it preserves the original relative order of equal-keyed elements in the sorted output. In other words, if two items have equal keys, they appear in the same order in the sorted output as they appeared in the original unsorted input.</p>
                        </div>
            
                        <h4>Example:</h4>
                        <p>Consider sorting a list of students by their marks. Two students, Alex and Ben, both have 85 marks.</p>
                        <p><strong>Unsorted List:</strong> `[(Charlie, 90), (Alex, 85), (David, 75), (Ben, 85)]`</p>
                        <p>In the original list, `(Alex, 85)` comes before `(Ben, 85)`.</p>
            
                        <div class="example-box">
                            <strong>Stable Sort Output:</strong><br>
                            `[(David, 75), <span class="highlight">(Alex, 85), (Ben, 85)</span>, (Charlie, 90)]`<br>
                            The relative order of Alex and Ben is maintained.
                        </div>
            
                        <div class="example-box" style="border-left-color: #f44336;">
                            <strong>Unstable Sort Output (Possible):</strong><br>
                            `[(David, 75), <span class="highlight">(Ben, 85), (Alex, 85)</span>, (Charlie, 90)]`<br>
                            The relative order of Alex and Ben has been swapped.
                        </div>
            
                        <h4>Examples of Algorithms:</h4>
                        <ul>
                            <li><strong>Stable Algorithms:</strong> Merge Sort, Insertion Sort, Bubble Sort.</li>
                            <li><strong>Unstable Algorithms:</strong> Quicksort, Heap Sort, Selection Sort.</li>
                        </ul>
                    </div>
                    <div id="q4c-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <div class="definition-box">
                            <strong>ස්ථායී (Stable) වර්ගීකරණ ඇල්ගොරිතමයක් යනු:</strong>
                            <p>වර්ගීකරණ ඇල්ගොරිතමයක් "ස්ථායී" ලෙස සලකනු ලබන්නේ, එය සමාන යතුරු (keys) සහිත මූලද්‍රව්‍යවල මුල් සාපේක්ෂ අනුපිළිවෙල වර්ගීකරණය කළ ප්‍රතිදානයේදී ද ආරක්ෂා කරන්නේ නම් ය. වෙනත් වචන වලින් කිවහොත්, අයිතම දෙකකට සමාන යතුරු තිබේ නම්, ඒවා මුල් ආදානයේ තිබූ අනුපිළිවෙලටම වර්ගීකරණය කළ ප්‍රතිදානයේදී ද දිස්වේ.</p>
                        </div>
            
                        <h4>උදාහරණය:</h4>
                        <p>සිසුන් ලැයිස්තුවක් ඔවුන්ගේ ලකුණු අනුව වර්ගීකරණය කිරීම සලකන්න. ඇලෙක්ස් සහ බෙන් යන දෙදෙනාටම ලකුණු 85ක් ඇත.</p>
                        <p><strong>නොවර්ග කළ ලැයිස්තුව:</strong> `[(චාලි, 90), (ඇලෙක්ස්, 85), (ඩේවිඩ්, 75), (බෙන්, 85)]`</p>
                        <p>මුල් ලැයිස්තුවේ, `(ඇලෙක්ස්, 85)` `(බෙන්, 85)` ට පෙර පැමිණේ.</p>
            
                        <div class="example-box">
                            <strong>ස්ථායී වර්ගීකරණ ප්‍රතිදානය:</strong><br>
                            `[(ඩේවිඩ්, 75), <span class="highlight">(ඇලෙක්ස්, 85), (බෙන්, 85)</span>, (චාලි, 90)]`<br>
                            ඇලෙක්ස් සහ බෙන්ගේ සාපේක්ෂ අනුපිළිවෙල එලෙසම පවතී.
                        </div>
            
                        <div class="example-box" style="border-left-color: #f44336;">
                            <strong>අස්ථායී වර්ගීකරණ ප්‍රතිදානය (විය හැකි):</strong><br>
                            `[(ඩේවිඩ්, 75), <span class="highlight">(බෙන්, 85), (ඇලෙක්ස්, 85)</span>, (චාලි, 90)]`<br>
                            ඇලෙක්ස් සහ බෙන්ගේ සාපේක්ෂ අනුපිළිවෙල මාරු වී ඇත.
                        </div>
            
                        <h4>ඇල්ගොරිතම උදාහරණ:</h4>
                        <ul>
                            <li><strong>ස්ථායී ඇල්ගොරිතම:</strong> Merge Sort, Insertion Sort, Bubble Sort.</li>
                            <li><strong>අස්ථායී ඇල්ගොරිතම:</strong> Quicksort, Heap Sort, Selection Sort.</li>
                        </ul>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        d) What is hashing? Briefly describe what a hash collision is and name one method to resolve it.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q4d-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q4d-si')">සිංහල පිළිතුර</button>
                    <div id="q4d-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="definition-box">
                            <strong>Hashing:</strong>
                            <p>Hashing is the process of converting an input of arbitrary size (the "key") into a fixed-size value, which is typically a smaller integer (the "hash value" or "hash code"). This is done using a mathematical function called a "hash function". Hashing is fundamental to the hash table data structure, which provides fast O(1) average time complexity for insertion, deletion, and search operations.</p>
                        </div>
            
                        <div class="definition-box" style="border-left-color: #f44336;">
                            <strong>Hash Collision:</strong>
                            <p>A hash collision occurs when two different keys produce the exact same hash value after being processed by the hash function. Since a hash table has a finite number of slots (buckets), it is inevitable that multiple keys will map to the same slot, especially with a large number of keys.</p>
                            <p class="formula">hash(key1) == hash(key2), where key1 ≠ key2</p>
                        </div>
            
                        <div class="example-box">
                            <strong>Collision Resolution Method: Separate Chaining</strong>
                            <p>One of the most common methods to resolve collisions is <strong>Separate Chaining</strong>. In this technique, each slot in the hash table does not hold a single value, but rather a pointer to another data structure, typically a linked list. When a collision occurs (i.e., a new key hashes to an already occupied slot), the new key-value pair is simply appended to the linked list at that slot.</p>
                            <br>
                            <p><strong>Advantages:</strong></p>
                            <ul>
                                <li>Simple to implement.</li>
                                <li>The hash table never gets "full" in the traditional sense.</li>
                            </ul>
                            <p><strong>Other methods include:</strong> Open Addressing (Linear Probing, Quadratic Probing, Double Hashing).</p>
                        </div>
                    </div>
                    <div id="q4d-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <div class="definition-box">
                            <strong>Hashing යනු:</strong>
                            <p>Hashing යනු ඕනෑම ප්‍රමාණයේ ආදානයක් ("key") ස්ථාවර ප්‍රමාණයේ අගයකට, සාමාන්‍යයෙන් කුඩා පූර්ණ සංඛ්‍යාවකට ("hash value" හෝ "hash code") පරිවර්තනය කිරීමේ ක්‍රියාවලියයි. මෙය "hash function" නමැති ගණිතමය ශ්‍රිතයක් භාවිතයෙන් සිදු කෙරේ. Hashing, hash table දත්ත ව්‍යුහය සඳහා මූලික වන අතර, එය ඇතුළත් කිරීම, මකා දැමීම සහ සෙවීම සඳහා සාමාන්‍යයෙන් O(1) කාල සංකීර්ණත්වයක් සපයයි.</p>
                        </div>
            
                        <div class="definition-box" style="border-left-color: #f44336;">
                            <strong>Hash Collision (ගැටුම):</strong>
                            <p>Hash ගැටුමක් යනු hash ශ්‍රිතය මගින් සකස් කිරීමෙන් පසු වෙනස් යතුරු දෙකක් එකම hash අගයක් නිපදවන විටය. Hash table එකක සීමිත ඉඩ ප්‍රමාණයක් (buckets) ඇති බැවින්, යතුරු විශාල සංඛ්‍යාවක් ඇති විට, බහු යතුරු එකම ඉඩකට සිතියම්ගත වීම නොවැළැක්විය හැකිය.</p>
                        </div>
            
                        <div class="example-box">
                            <strong>ගැටුම් නිරාකරණ ක්‍රමය: Separate Chaining</strong>
                            <p>ගැටුම් නිරාකරණය සඳහා වඩාත් පොදු ක්‍රමයක් වන්නේ <strong>Separate Chaining</strong> ය. මෙම තාක්ෂණයේදී, hash table එකේ සෑම ඉඩකම තනි අගයක් වෙනුවට, සම්බන්ධිත ලැයිස්තුවක් (linked list) වැනි වෙනත් දත්ත ව්‍යුහයකට දර්ශකයක් තබා ගනී. ගැටුමක් සිදු වූ විට, නව යතුරු-අගය යුගලය එම ඉඩට අනුරූප සම්බන්ධිත ලැයිස්තුවට එකතු කරනු ලැබේ.</p>
                        </div>
                    </div>
                </div>
            
                 <div class="sub-question">
                    <div class="sub-question-label">
                        e) Trace the passes of the Bubble Sort algorithm on the array: `[5, 1, 4, 2, 8]`.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q4e-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q4e-si')">සිංහල පිළිතුර</button>
                    <div id="q4e-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <p>Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. After each pass, the next largest element "bubbles up" to its correct position at the end of the array.</p>
            
                        <div class="code-block">
<pre>
Original Array:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)]

<span class="comment">// Pass 1:</span>
[<span class="highlight">5, 1</span>, 4, 2, 8] -> [<span class="highlight">1, 5</span>, 4, 2, 8] (Swap: 5 > 1)
[1, <span class="highlight">5, 4</span>, 2, 8] -> [1, <span class="highlight">4, 5</span>, 2, 8] (Swap: 5 > 4)
[1, 4, <span class="highlight">5, 2</span>, 8] -> [1, 4, <span class="highlight">2, 5</span>, 8] (Swap: 5 > 2)
[1, 4, 2, <span class="highlight">5, 8</span>] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (No swap: 5 < 8)
<span class="comment">// Result after Pass 1:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (Largest element 8 is in place)</span>

<span class="comment">// Pass 2:</span>
[<span class="highlight">1, 4</span>, 2, 5, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (No swap: 1 < 4)
[1, <span class="highlight">4, 2</span>, 5, 8] -> [1, <span class="highlight">2, 4</span>, 5, 8] (Swap: 4 > 2)
[1, 2, <span class="highlight">4, 5</span>, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (No swap: 4 < 5)
<span class="comment">// Result after Pass 2:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (Second largest element 5 is in place)</span>

<span class="comment">// Pass 3:</span>
[<span class="highlight">1, 2</span>, 4, 5, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (No swap: 1 < 2)
[1, <span class="highlight">2, 4</span>, 5, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (No swap: 2 < 4)
<span class="comment">// Result after Pass 3:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (No swaps occurred, array is sorted)</span>
<span class="comment">// The algorithm can terminate early if a pass completes with no swaps.</span>

Final Sorted Array:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)]
</pre>
                        </div>
                    </div>
                    <div id="q4e-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <p>Bubble Sort ඇල්ගොරිතමය නැවත නැවතත් ලැයිස්තුව හරහා ගමන් කර, යාබද මූලද්‍රව්‍ය සංසන්දනය කර, ඒවා වැරදි අනුපිළිවෙලක තිබේ නම් මාරු කරයි. සෑම වටයකින්ම පසු, ඊළඟ විශාලතම මූලද්‍රව්‍යය අරාවේ අවසානයේ එහි නියමිත ස්ථානයට "බුබුලක් මෙන්" ඉහළට පැමිණේ.</p>
            
                        <div class="code-block">
<pre>
මුල් අරාව:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)]

<span class="comment">// වටය 1:</span>
[<span class="highlight">5, 1</span>, 4, 2, 8] -> [<span class="highlight">1, 5</span>, 4, 2, 8] (මාරු කරන්න: 5 > 1)
[1, <span class="highlight">5, 4</span>, 2, 8] -> [1, <span class="highlight">4, 5</span>, 2, 8] (මාරු කරන්න: 5 > 4)
[1, 4, <span class="highlight">5, 2</span>, 8] -> [1, 4, <span class="highlight">2, 5</span>, 8] (මාරු කරන්න: 5 > 2)
[1, 4, 2, <span class="highlight">5, 8</span>] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (මාරු නොකරන්න: 5 < 8)
<span class="comment">// වටය 1 න් පසු:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (විශාලතම මූලද්‍රව්‍ය 8 නියමිත ස්ථානයේ)</span>

<span class="comment">// වටය 2:</span>
[<span class="highlight">1, 4</span>, 2, 5, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (මාරු නොකරන්න: 1 < 4)
[1, <span class="highlight">4, 2</span>, 5, 8] -> [1, <span class="highlight">2, 4</span>, 5, 8] (මාරු කරන්න: 4 > 2)
[1, 2, <span class="highlight">4, 5</span>, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (මාරු නොකරන්න: 4 < 5)
<span class="comment">// වටය 2 න් පසු:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (දෙවන විශාලතම මූලද්‍රව්‍ය 5 නියමිත ස්ථානයේ)</span>

<span class="comment">// වටය 3:</span>
[<span class="highlight">1, 2</span>, 4, 5, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (මාරු නොකරන්න: 1 < 2)
[1, <span class="highlight">2, 4</span>, 5, 8] ->[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (මාරු නොකරන්න: 2 < 4)
<span class="comment">// වටය 3 න් පසු:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)] (මාරු කිරීමක් සිදු නොවීය, අරාව වර්ගීකරණය වී ඇත)</span>

අවසාන වර්ගීකරණය කළ අරාව:[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGGjmeIHKkNBB8H4hW4ysBowfZ-3WChNAqYTIsx44jUiKgKAzrjqZ5RG06dM9Cm2ssfpmtr56KiIly9UV999OSJkqH-K3yMBVcW0OCdzt9S9Mub5m6-dKa8RQAsIa1_hZ_FYsjjqJy8aZEopAiPmMMBunpprS_9RRzBVHHNB0CGkocMutHvrTsCpHKjHbWtNhkBI0GDHDY0LVFmkEjqrw%3D%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG9xeD0AoPB-T-it0CoMisUHD0RupvossflmSvaGhFPujhJQlc2y-R4vXwTLpHkO95u7x9RJmMrB-uriJzMQzGffNut7BQhOlAVTpAlN5N_JxFXHxs-nNTaP4i8aHSBPilzEIxCPONsKN5SalAj)][[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbDPzN6uPDkT-5VX4VwxvKjiNo5VwnqAuie0KskT7Ep0bSlWklGL5MNqrt3qHG-mp4qdeL_dSZANWlHbzbAKYEMTIATCgrma7_2f7nWqKD_3CwLR_S58tH6T-y2vdoKcnou38LMDiI_sAXGfSSu1EZJJzj2xehT0B-YP2UrQ%3D%3D)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHGlwAnPTXAMQfpeOYGREhTqCxd9Nh2hdgkFUqh7f0tdTGmLT5r7bNFJ7iyrStP_TO2_0sRxHQs91iL8ssGA2gaoiCcrTKVU9tVdLX47zvVwvhJJeoQSRMhc9Xj8anYlnkN2ge_Dk6fhT3ppEvOZskm_dZ-4uo52w0MdE6YdmF2pJVLnKW__2fOs8Wb9w%3D%3D)]
</pre>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- QUESTION 5 -->
            <div class="question-block">
                <div class="question-number">Question 5</div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        a) What is a Binary Search Tree (BST)? List its fundamental properties.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q5a-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q5a-si')">සිංහල පිළිතුර</button>
                    <div id="q5a-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="definition-box">
                            <strong>Binary Search Tree (BST) Definition:</strong>
                            <p>A Binary Search Tree is a node-based binary tree data structure which has the following properties. It is designed to allow for efficient searching, insertion, and deletion of elements.</p>
                        </div>
            
                        <h4>Fundamental Properties:</h4>
                        <ol>
                            <li><strong>Binary Tree Property:</strong> Each node has at most two children, referred to as the left child and the right child.</li>
                            <li><strong>BST Property (Ordering):</strong>
                                <ul>
                                    <li>All keys (values) in the left subtree of a node are less than the node's key.</li>
                                    <li>All keys (values) in the right subtree of a node are greater than the node's key.</li>
                                </ul>
                            </li>
                            <li><strong>Recursive Structure:</strong> Both the left and right subtrees of any node must also be binary search trees.</li>
                            <li><strong>No Duplicate Keys:</strong> In a standard BST, all keys must be unique. (Some variations may allow duplicates).</li>
                        </ol>
            
                        <div class="example-box">
                            <strong>Example:</strong>
                            <div class="code-block" style="text-align: center; color: white;">
<pre>
      [ 8 ]
      /   \
    [ 3 ] [ 10 ]
    /  \      \
  [ 1 ][ 6 ]    [ 14 ]
      /  \    /
    [ 4 ][ 7 ][ 13 ]

- Left of 8: All values < 8 (3, 1, 6, 4, 7)
- Right of 8: All values > 8 (10, 14, 13)
- This property holds true for every node in the tree.
</pre>
                            </div>
                        </div>
                    </div>
                    <div id="q5a-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <div class="definition-box">
                            <strong>ද්විමය සෙවුම් ගස (Binary Search Tree - BST) යනු:</strong>
                            <p>Binary Search Tree යනු පහත ගුණාංග ඇති, නෝඩ් (node) මත පදනම් වූ ද්විමය ගස් (binary tree) දත්ත ව්‍යුහයකි. එය මූලද්‍රව්‍ය කාර්යක්ෂමව සෙවීම, ඇතුළත් කිරීම සහ මකා දැමීම සඳහා නිර්මාණය කර ඇත.</p>
                        </div>
            
                        <h4>මූලික ගුණාංග:</h4>
                        <ol>
                            <li><strong>ද්විමය ගස් ගුණාංගය:</strong> සෑම නෝඩයකටම උපරිම වශයෙන් දරුවන් දෙදෙනෙකු සිටින අතර, ඔවුන් වම් දරුවා සහ දකුණු දරුවා ලෙස හැඳින්වේ.</li>
                            <li><strong>BST ගුණාංගය (පිළිවෙල):</strong>
                                <ul>
                                    <li>නෝඩයක වම් අනු-ගසෙහි ඇති සියලුම යතුරු (අගයන්) එම නෝඩයේ යතුරට වඩා අඩුය.</li>
                                    <li>නෝඩයක දකුණු අනු-ගසෙහි ඇති සියලුම යතුරු (අගයන්) එම නෝඩයේ යතුරට වඩා වැඩිය.</li>
                                </ul>
                            </li>
                            <li><strong>පුනරාවර්තන ව්‍යුහය:</strong> ඕනෑම නෝඩයක වම් සහ දකුණු අනු-ගස් ද ද්විමය සෙවුම් ගස් විය යුතුය.</li>
                            <li><strong>අනුපිටපත් යතුරු නැත:</strong> සම්මත BST එකක, සියලුම යතුරු අනන්‍ය විය යුතුය.</li>
                        </ol>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        b) Given a BST, list the sequence of nodes visited for In-order, Pre-order, and Post-order traversals.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q5b-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q5b-si')">සිංහල පිළිතුර</button>
                    <div id="q5b-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <div class="code-block" style="text-align: center; color: white;">
<pre>
          [ 25 ]
          /    \
        [ 15 ]  [ 50 ]
        /   \   /   \
      [ 10 ][ 22 ][ 35 ][ 70 ]
      /  \   /      /  \
    [ 4 ][ 12 ][ 18 ]  [ 66 ][ 90 ]
</pre>
                        </div>
                        <div class="definition-box">
                            <strong>In-order Traversal (Left, Root, Right):</strong>
                            <p>Visits nodes in ascending order.</p>
                            <p class="formula">4, 10, 12, 15, 18, 22, 25, 35, 50, 66, 70, 90</p>
                        </div>
            
                        <div class="definition-box">
                            <strong>Pre-order Traversal (Root, Left, Right):</strong>
                            <p>Useful for creating a copy of the tree.</p>
                            <p class="formula">25, 15, 10, 4, 12, 22, 18, 50, 35, 70, 66, 90</p>
                        </div>
            
                        <div class="definition-box">
                            <strong>Post-order Traversal (Left, Right, Root):</strong>
                            <p>Useful for deleting the tree from memory.</p>
                            <p class="formula">4, 12, 10, 18, 22, 15, 35, 66, 90, 70, 50, 25</p>
                        </div>
                    </div>
                    <div id="q5b-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                         <div class="code-block" style="text-align: center; color: white;">
 <pre>
           [ 25 ]
           /    \
         [ 15 ]  [ 50 ]
         /   \   /   \
       [ 10 ][ 22 ][ 35 ][ 70 ]
       /  \   /      /  \
     [ 4 ][ 12 ][ 18 ]  [ 66 ][ 90 ]
 </pre>
                         </div>
                         <div class="definition-box">
                             <strong>In-order Traversal (වම, මූලය, දකුණ):</strong>
                             <p>නෝඩ් ආරෝහණ අනුපිළිවෙලට සංචාරය කරයි.</p>
                             <p class="formula">4, 10, 12, 15, 18, 22, 25, 35, 50, 66, 70, 90</p>
                         </div>
             
                         <div class="definition-box">
                             <strong>Pre-order Traversal (මූලය, වම, දකුණ):</strong>
                             <p>ගසේ පිටපතක් සෑදීමට ප්‍රයෝජනවත් වේ.</p>
                             <p class="formula">25, 15, 10, 4, 12, 22, 18, 50, 35, 70, 66, 90</p>
                         </div>
             
                         <div class="definition-box">
                             <strong>Post-order Traversal (වම, දකුණ, මූලය):</strong>
                             <p>මතකයෙන් ගස මකා දැමීමට ප්‍රයෝජනවත් වේ.</p>
                             <p class="formula">4, 12, 10, 18, 22, 15, 35, 66, 90, 70, 50, 25</p>
                         </div>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        c) Compare Adjacency Matrix and Adjacency List for representing graphs. When would you prefer one over the other?
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q5c-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q5c-si')">සිංහල පිළිතුර</button>
                    <div id="q5c-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Adjacency Matrix</th>
                                    <th>Adjacency List</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Representation</strong></td>
                                    <td>V x V matrix (2D array) where `adj[i][j] = 1` if an edge exists from vertex i to j.</td>
                                    <td>An array of linked lists, where `adj[i]` holds a list of vertices adjacent to vertex i.</td>
                                </tr>
                                <tr>
                                    <td><strong>Space Complexity</strong></td>
                                    <td>O(V²) - V is the number of vertices.</td>
                                    <td>O(V + E) - E is the number of edges.</td>
                                </tr>
                                <tr>
                                    <td><strong>Check for Edge (u, v)</strong></td>
                                    <td>O(1) - Just check `matrix[u][v]`.</td>
                                    <td>O(deg(u)) - Must traverse the list for vertex u. `deg(u)` is the degree of u.</td>
                                </tr>
                                <tr>
                                    <td><strong>Iterate over all neighbors of u</strong></td>
                                    <td>O(V) - Must check the entire row for vertex u.</td>
                                    <td>O(deg(u)) - Just traverse the list for vertex u.</td>
                                </tr>
                            </tbody>
                        </table>
            
                        <h4>When to Prefer Which:</h4>
                        <div class="example-box">
                            <strong>Prefer Adjacency Matrix when:</strong>
                            <ul>
                                <li>The graph is <strong>dense</strong> (number of edges E is close to V²). In this case, O(V²) space is acceptable.</li>
                                <li>You need to frequently check for the existence of an edge between any two vertices (O(1) is very fast).</li>
                                <li>The graph is small.</li>
                            </ul>
                        </div>
            
                        <div class="example-box" style="border-left-color: #4caf50;">
                            <strong>Prefer Adjacency List when:</strong>
                            <ul>
                                <li>The graph is <strong>sparse</strong> (number of edges E is much smaller than V²). The O(V+E) space is much more efficient.</li>
                                <li>The main operation is to iterate over the neighbors of a vertex.</li>
                                <li>The graph is large. This is the most common representation for real-world graphs.</li>
                            </ul>
                        </div>
                    </div>
                    <div id="q5c-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>ලක්ෂණය</th>
                                    <th>Adjacency Matrix</th>
                                    <th>Adjacency List</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>නිරූපණය</strong></td>
                                    <td>V x V matrix එකක්. ශීර්ෂ i සිට j ට දාරයක් ඇත්නම් `adj[i][j] = 1` වේ.</td>
                                    <td>සම්බන්ධිත ලැයිස්තු අරාවකි. `adj[i]` හි ශීර්ෂ i ට යාබද ශීර්ෂ ලැයිස්තුවක් ඇත.</td>
                                </tr>
                                <tr>
                                    <td><strong>අවකාශ සංකීර්ණත්වය</strong></td>
                                    <td>O(V²) - V යනු ශීර්ෂ ගණන.</td>
                                    <td>O(V + E) - E යනු දාර ගණන.</td>
                                </tr>
                                <tr>
                                    <td><strong>දාරයක් (u, v) පරීක්ෂා කිරීම</strong></td>
                                    <td>O(1) - `matrix[u][v]` පරීක්ෂා කිරීම පමණි.</td>
                                    <td>O(deg(u)) - ශීර්ෂ u සඳහා ලැයිස්තුව හරහා යා යුතුය.</td>
                                </tr>
                            </tbody>
                        </table>
            
                        <h4>වඩාත් සුදුසු අවස්ථා:</h4>
                        <div class="example-box">
                            <strong>Adjacency Matrix භාවිතා කළ යුතු අවස්ථා:</strong>
                            <ul>
                                <li>ප්‍රස්තාරය <strong>ඝන (dense)</strong> වන විට (දාර ගණන E, V² ට ආසන්න විට).</li>
                                <li>ඕනෑම ශීර්ෂ දෙකක් අතර දාරයක් තිබේදැයි නිතර පරීක්ෂා කිරීමට අවශ්‍ය විට.</li>
                                <li>ප්‍රස්තාරය කුඩා විට.</li>
                            </ul>
                        </div>
            
                        <div class="example-box" style="border-left-color: #4caf50;">
                            <strong>Adjacency List භාවිතා කළ යුතු අවස්ථා:</strong>
                            <ul>
                                <li>ප්‍රස්තාරය <strong>විරල (sparse)</strong> වන විට (දාර ගණන E, V² ට වඩා බෙහෙවින් අඩු විට). O(V+E) අවකාශය වඩා කාර්යක්ෂම වේ.</li>
                                <li>ප්‍රධාන මෙහෙයුම වන්නේ ශීර්ෂයක අසල්වැසියන් හරහා ගමන් කිරීම විට.</li>
                                <li>ප්‍රස්තාරය විශාල විට.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        d) Explain the difference between Breadth-First Search (BFS) and Depth-First Search (DFS) graph traversal algorithms.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q5d-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q5d-si')">සිංහල පිළිතුර</button>
                    <div id="q5d-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>Aspect</th>
                                    <th>Breadth-First Search (BFS)</th>
                                    <th>Depth-First Search (DFS)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Traversal Method</strong></td>
                                    <td>Explores level by level. It visits all neighbors of a node before moving to the next level.</td>
                                    <td>Explores as far as possible along each branch before backtracking.</td>
                                </tr>
                                <tr>
                                    <td><strong>Data Structure Used</strong></td>
                                    <td><strong>Queue</strong> (FIFO)</td>
                                    <td><strong>Stack</strong> (LIFO) - can be implemented with recursion (call stack).</td>
                                </tr>
                                <tr>
                                    <td><strong>Finding Shortest Path</strong></td>
                                    <td>Guaranteed to find the shortest path in an unweighted graph.</td>
                                    <td>Not guaranteed to find the shortest path.</td>
                                </tr>
                                <tr>
                                    <td><strong>Space Complexity</strong></td>
                                    <td>Can be large, O(W) where W is the maximum width of the graph. Needs to store all nodes at a level.</td>
                                    <td>More memory efficient, O(H) where H is the maximum height/depth of the graph.</td>
                                </tr>
                                <tr>
                                    <td><strong>Applications</strong></td>
                                    <td>Shortest path in unweighted graphs, finding connected components, social network analysis.</td>
                                    <td>Topological sorting, cycle detection, solving puzzles (e.g., mazes).</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <div id="q5d-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>අංගය</th>
                                    <th>Breadth-First Search (BFS)</th>
                                    <th>Depth-First Search (DFS)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>සංචාරණ ක්‍රමය</strong></td>
                                    <td>මට්ටමින් මට්ටම ගවේෂණය කරයි. ඊළඟ මට්ටමට යාමට පෙර නෝඩයක සියලුම අසල්වැසියන් වෙත පිවිසෙයි.</td>
                                    <td>ආපසු හැරීමට පෙර එක් එක් ශාඛාව ඔස්සේ හැකි තරම් දුරට ගවේෂණය කරයි.</td>
                                </tr>
                                <tr>
                                    <td><strong>භාවිතා කරන දත්ත ව්‍යුහය</strong></td>
                                    <td><strong>Queue (පෝලිම)</strong> - FIFO</td>
                                    <td><strong>Stack (අට්ටිය)</strong> - LIFO (පුනරාවර්තනය මගින් ක්‍රියාත්මක කළ හැක).</td>
                                </tr>
                                <tr>
                                    <td><strong>කෙටිම මාර්ගය සෙවීම</strong></td>
                                    <td>බර රහිත ප්‍රස්තාරයක කෙටිම මාර්ගය සොයා ගැනීම සහතික කරයි.</td>
                                    <td>කෙටිම මාර්ගය සොයා ගැනීම සහතික නොකරයි.</td>
                                </tr>
                                <tr>
                                    <td><strong>යෙදුම්</strong></td>
                                    <td>බර රහිත ප්‍රස්තාරවල කෙටිම මාර්ගය, සම්බන්ධිත සංරචක සෙවීම, සමාජ ජාල විශ්ලේෂණය.</td>
                                    <td>Topology වර්ගීකරණය, චක්‍ර හඳුනාගැනීම, ප්‍රහේලිකා විසඳීම (උදා: වංකගිරි).</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            
                <div class="sub-question">
                    <div class="sub-question-label">
                        e) Write a C/C++ function to implement the insertion of a new node into a Binary Search Tree.
                        <span class="marks">(04 marks)</span>
                    </div>
                    <button class="answer-toggle" onclick="toggleAnswer('q5e-en')">Show English Answer</button>
                    <button class="answer-toggle sinhala" onclick="toggleAnswer('q5e-si')">සිංහල පිළිතුර</button>
                    <div id="q5e-en" class="answer-content">
                        <h4>Answer (English):</h4>
                        <p>The function will recursively traverse the tree to find the correct empty spot for the new node while maintaining the BST properties.</p>
                        <div class="code-block">
<pre><span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>

<span class="comment">// Node structure for the BST</span>
<span class="keyword">struct</span> <span class="type">Node</span> {
    <span class="keyword">int</span> key;
    <span class="type">Node</span> *left, *right;
};

<span class="comment">// Function to create a new node</span>
<span class="type">Node</span>* <span class="function">createNode</span>(<span class="keyword">int</span> item) {
    <span class="type">Node</span>* temp = <span class="keyword">new</span> <span class="type">Node</span>;
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = <span class="keyword">nullptr</span>;
    <span class="keyword">return</span> temp;
}

<span class="comment">// Recursive function to insert a new key in BST</span>
<span class="type">Node</span>* <span class="function">insert</span>(<span class="type">Node</span>* node, <span class="keyword">int</span> key) {
    <span class="comment">// If the tree is empty, return a new node</span>
    <span class="keyword">if</span> (node == <span class="keyword">nullptr</span>) {
        <span class="keyword">return</span> <span class="function">createNode</span>(key);
    }

    <span class="comment">// Otherwise, recur down the tree</span>
    <span class="keyword">if</span> (key &lt; node-&gt;key) {
        node-&gt;left = <span class="function">insert</span>(node-&gt;left, key);
    } <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) {
        node-&gt;right = <span class="function">insert</span>(node-&gt;right, key);
    }

    <span class="comment">// Return the (unchanged) node pointer</span>
    <span class="keyword">return</span> node;
}

<span class="comment">// Helper function for in-order traversal to verify</span>
<span class="keyword">void</span> <span class="function">inorder</span>(<span class="type">Node</span>* root) {
    <span class="keyword">if</span> (root != <span class="keyword">nullptr</span>) {
        <span class="function">inorder</span>(root-&gt;left);
        std::cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">" "</span>;
        <span class="function">inorder</span>(root-&gt;right);
    }
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="type">Node</span>* root = <span class="keyword">nullptr</span>;
    root = <span class="function">insert</span>(root, <span class="number">50</span>);
    <span class="function">insert</span>(root, <span class="number">30</span>);
    <span class="function">insert</span>(root, <span class="number">20</span>);
    <span class="function">insert</span>(root, <span class="number">40</span>);
    <span class="function">insert</span>(root, <span class="number">70</span>);
    <span class="function">insert</span>(root, <span class="number">60</span>);
    <span class="function">insert</span>(root, <span class="number">80</span>);

    <span class="comment">// Print in-order traversal of the BST</span>
    std::cout &lt;&lt; <span class="string">"In-order traversal: "</span>;
    <span class="function">inorder</span>(root); <span class="comment">// Output: 20 30 40 50 60 70 80</span>
    std::cout &lt;&lt; std::endl;

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre>
                        </div>
                        <div class="note-box">
                            <strong>Complexity Analysis:</strong>
                            <ul>
                                <li><strong>Average Case Time Complexity:</strong> O(log n) for a balanced tree.</li>
                                <li><strong>Worst Case Time Complexity:</strong> O(n) for a skewed/unbalanced tree (which resembles a linked list).</li>
                                <li><strong>Space Complexity:</strong> O(h) where h is the height of the tree, for the recursion stack.</li>
                            </ul>
                        </div>
                    </div>
                    <div id="q5e-si" class="answer-content sinhala-text">
                        <h4>පිළිතුර (සිංහල):</h4>
                        <p>මෙම ශ්‍රිතය BST ගුණාංග පවත්වා ගනිමින්, නව නෝඩය සඳහා නිවැරදි හිස් ස්ථානය සොයා ගැනීමට පුනරාවර්තන ලෙස ගස හරහා ගමන් කරයි.</p>
                        <p>ඉහත C++ කේතය `insert` නම් ශ්‍රිතයක් ක්‍රියාත්මක කරයි. එයට root නෝඩය සහ ඇතුළත් කළ යුතු යතුර ලබා දෙනු ලැබේ. යතුර root නෝඩයේ යතුරට වඩා අඩු නම්, එය වම් අනු-ගසට යයි; වැඩි නම්, එය දකුණු අනු-ගසට යයි. මෙම ක්‍රියාවලිය හිස් ස්ථානයක් (nullptr) හමුවන තෙක් පුනරාවර්තනය වන අතර, එහිදී නව නෝඩය නිර්මාණය කර ඇතුළත් කරනු ලැබේ.</p>
                        <div class="note-box">
                            <strong>සංකීර්ණතා විශ්ලේෂණය:</strong>
                            <ul>
                                <li><strong>සාමාන්‍ය අවස්ථාව:</strong> O(log n) (සමබර ගසක් සඳහා).</li>
                                <li><strong>නරකම අවස්ථාව:</strong> O(n) (නොසමබර ගසක් සඳහා).</li>
                                <li><strong>අවකාශ සංකීර්ණත්වය:</strong> O(h) h යනු ගසේ උස වේ (පුනරාවර්තන stackය සඳහා).</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <div style="background: #f8f9fa; padding: 30px; text-align: center; border-top: 3px solid #667eea;">
            <h3 style="color: #667eea;">📚 Study Tips</h3>
            <p style="max-width: 800px; margin: 20px auto; line-height: 1.8;">
                This exam paper mirrors the structure of the DSA course. Each question has detailed solutions with code examples, complexity analysis, and explanations in both English and Sinhala. Use the toggle buttons to switch between languages and practice implementing the algorithms yourself.
            </p>
            <p style="color: #764ba2; font-weight: 600; margin-top: 20px;">
                Good luck with your exam! 🎓
            </p>
        </div>
    </div>

    <script>
        function toggleAnswer(id) {
            const element = document.getElementById(id);
            
            // Close all other answers in the same question
            const parentQuestion = element.closest('.sub-question');
            const allAnswers = parentQuestion.querySelectorAll('.answer-content');
            allAnswers.forEach(answer => {
                if (answer.id !== id) {
                    answer.classList.remove('show');
                }
            });
            
            // Toggle current answer
            element.classList.toggle('show');
            
            // Smooth scroll to answer
            if (element.classList.contains('show')) {
                setTimeout(() => {
                    element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }, 100);
            }
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Press 'Esc' to close all answers
            if (e.key === 'Escape') {
                document.querySelectorAll('.answer-content.show').forEach(answer => {
                    answer.classList.remove('show');
                });
            }
        });

        // Add animation on page load
        window.addEventListener('load', function() {
            const questionBlocks = document.querySelectorAll('.question-block');
            questionBlocks.forEach((block, index) => {
                block.style.opacity = '0';
                block.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    block.style.transition = 'all 0.5s ease-out';
                    block.style.opacity = '1';
                    block.style.transform = 'translateY(0)';
                }, index * 100);
            });
        });
    </script>
</body>
</html>