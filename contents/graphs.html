<!DOCTYPE html>
<html lang="si">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs - ‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä | DSA ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω‡∑ô‡∂±‡∑ä</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Sinhala:wght@400;700&family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans Sinhala', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .navbar {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }
        .navbar-brand {
            font-weight: 700;
            font-size: 1.3rem;
            color: #667eea !important;
        }
        .content-wrapper {
            background: white;
            margin: 100px auto 50px;
            padding: 50px;
            border-radius: 20px;
            max-width: 1000px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        h1 {
            color: #667eea;
            font-weight: 700;
            margin-bottom: 30px;
            font-size: 2.5rem;
        }
        h2 {
            color: #764ba2;
            font-weight: 700;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        h3 {
            color: #555;
            font-weight: 600;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        p, li {
            line-height: 1.8;
            font-size: 1.1rem;
            color: #444;
        }
        .code-container {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Fira Code', monospace;
            overflow-x: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .code-line {
            display: block;
            padding: 2px 0;
        }
        .comment {
            color: #6a9955;
            font-style: italic;
        }
        .keyword {
            color: #569cd6;
        }
        .function {
            color: #dcdcaa;
        }
        .string {
            color: #ce9178;
        }
        .number {
            color: #b5cea8;
        }
        .highlight-box {
            background: #f0f7ff;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .complexity-table {
            margin: 20px 0;
        }
        .complexity-table th {
            background: #667eea;
            color: white;
        }
        .diagram {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .back-btn {
            margin-top: 40px;
            background: #667eea;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-weight: 600;
            transition: transform 0.3s;
        }
        .back-btn:hover {
            transform: translateY(-2px);
            background: #5568d3;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-light fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../index.html">üìò DSA ‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω‡∑ô‡∂±‡∑ä</a>
        </div>
    </nav>

    <div class="content-wrapper">
        <h1>üï∏Ô∏è Graphs - ‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä</h1>
        
        <h2>‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä ‡∂∫‡∂±‡∑î ‡∂ö‡∑î‡∂∏‡∂ö‡∑ä‡∂Ø?</h2>
        <p>Graph ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂∫‡∂±‡∑î vertices (‡∂Ω‡∂ö‡∑ä‡∑Ç‡∑ä‚Äç‡∂∫) ‡∑Ñ‡∑ù nodes ‡∑É‡∑Ñ edges (‡∂Ø‡∑è‡∂ª) ‡∑Ä‡∂Ω‡∑í‡∂±‡∑ä ‡∑É‡∂∏‡∂±‡∑ä‡∑Ä‡∑í‡∂≠ ‡∂Ø‡∂≠‡∑ä‡∂≠ ‡∑Ä‡∑ä‚Äç‡∂∫‡∑î‡∑Ñ‡∂∫‡∂ö‡∑í. ‡∂ë‡∂∫ ‡∑É‡∂Ç‡∂ö‡∑ì‡∂ª‡∑ä‡∂´ ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞‡∂≠‡∑è ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂∫‡∑í - ‡∑É‡∂∏‡∑è‡∂¢ ‡∂¢‡∑è‡∂Ω, ‡∂∏‡∑è‡∂ª‡∑ä‡∂ú ‡∂¢‡∑è‡∂Ω, network connections ‡∑Ä‡∑ê‡∂±‡∑í ‡∂Ø‡∑ö ‡∑É‡∂≥‡∑Ñ‡∑è.</p>
        
        <div class="highlight-box">
            <strong>‡∂¥‡∑ä‚Äç‡∂ª‡∂∞‡∑è‡∂± ‡∑É‡∂Ç‡∂ö‡∂Ω‡∑ä‡∂¥:</strong>
            <ul>
                <li><strong>Vertex/Node:</strong> ‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä ‡∂ë‡∂ö‡∑ö ‡∂Ω‡∂ö‡∑ä‡∑Ç‡∑ä‚Äç‡∂∫‡∂∫‡∂ö‡∑ä</li>
                <li><strong>Edge:</strong> vertices ‡∂Ø‡∑ô‡∂ö‡∂ö‡∑ä ‡∂Ö‡∂≠‡∂ª ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞‡∂≠‡∑è‡∑Ä‡∂∫</li>
                <li><strong>Directed Graph:</strong> edges ‡∑Ä‡∂Ω‡∂ß ‡∂Ø‡∑í‡∑Å‡∑è‡∑Ä‡∂ö‡∑ä ‡∂á‡∂≠</li>
                <li><strong>Undirected Graph:</strong> edges ‡∑Ä‡∂Ω‡∂ß ‡∂Ø‡∑í‡∑Å‡∑è‡∑Ä‡∂ö‡∑ä ‡∂±‡∑ê‡∂≠</li>
                <li><strong>Weighted Graph:</strong> edges ‡∑Ä‡∂Ω‡∂ß ‡∑Ä‡∂ß‡∑í‡∂±‡∑è‡∂ö‡∂∏‡∑ä ‡∂á‡∂≠</li>
            </ul>
        </div>

        <h2>‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´ ‡∂ö‡∑ä‚Äç‡∂ª‡∂∏</h2>
        
        <h3>1. Adjacency Matrix (‡∂Ü‡∑É‡∂±‡∑ä‡∂± ‡∂±‡∑ä‚Äç‡∂∫‡∑è‡∑É‡∂∫)</h3>
        <p>2D array ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫‡∑ô‡∂±‡∑ä vertices ‡∂Ö‡∂≠‡∂ª ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞‡∂≠‡∑è ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫ ‡∂ö‡∂ª‡∂∫‡∑í.</p>

        <div class="code-container">
<span class="code-line"><span class="comment">// Adjacency Matrix ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫‡∑ô‡∂±‡∑ä Graph ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="code-line"><span class="keyword">#define</span> MAX <span class="number">10</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Graph structure - adjacency matrix ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫‡∑ô‡∂±‡∑ä</span></span>
<span class="code-line"><span class="keyword">typedef struct</span> {</span>
<span class="code-line">    <span class="keyword">int</span> vertices;                    <span class="comment">// vertices ‡∂ú‡∂´‡∂±</span></span>
<span class="code-line">    <span class="keyword">int</span> adjMatrix[MAX][MAX];         <span class="comment">// adjacency matrix</span></span>
<span class="code-line">} Graph;</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Graph ‡∂ë‡∂ö‡∂ö‡∑ä initialize ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">initGraph</span>(Graph* g, <span class="keyword">int</span> vertices) {</span>
<span class="code-line">    g->vertices = vertices;             <span class="comment">// vertices ‡∂ú‡∂´‡∂± set ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    </span>
<span class="code-line">    <span class="comment">// ‡∑É‡∑í‡∂∫‡∂Ω‡∑î edges 0 ‡∂ö‡∂ª‡∂±‡∑ä‡∂± (connections ‡∂±‡∑ê‡∂≠)</span></span>
<span class="code-line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < vertices; i++) {</span>
<span class="code-line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < vertices; j++) {</span>
<span class="code-line">            g->adjMatrix[i][j] = <span class="number">0</span>;   <span class="comment">// ‡∂ë‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ä edge 0 ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        }</span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Edge ‡∂ë‡∂ö‡∂ö‡∑ä add ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">addEdge</span>(Graph* g, <span class="keyword">int</span> src, <span class="keyword">int</span> dest) {</span>
<span class="code-line">    g->adjMatrix[src][dest] = <span class="number">1</span>;        <span class="comment">// src ‡∑É‡∑í‡∂ß dest ‡∑Ä‡∑ô‡∂≠ edge ‡∂ë‡∂ö‡∂ö‡∑ä</span></span>
<span class="code-line">    g->adjMatrix[dest][src] = <span class="number">1</span>;        <span class="comment">// undirected ‡∂±‡∂∏‡∑ä ‡∂Ø‡∑ô‡∂¥‡∑ê‡∂≠‡∑ä‡∂≠‡∂ß‡∂∏</span></span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Graph ‡∂ë‡∂ö print ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">printGraph</span>(Graph* g) {</span>
<span class="code-line">    <span class="function">printf</span>(<span class="string">"Adjacency Matrix:\n"</span>);</span>
<span class="code-line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < g->vertices; i++) {    <span class="comment">// ‡∂ë‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ä row</span></span>
<span class="code-line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < g->vertices; j++) { <span class="comment">// ‡∂ë‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ä column</span></span>
<span class="code-line">            <span class="function">printf</span>(<span class="string">"%d "</span>, g->adjMatrix[i][j]); <span class="comment">// value print ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        }</span>
<span class="code-line">        <span class="function">printf</span>(<span class="string">"\n"</span>);                      <span class="comment">// row ‡∂ë‡∂ö ‡∂Ö‡∑Ä‡∑É‡∂±‡∑ä ‡∑Ä‡∑î‡∂´‡∑è‡∂∏ new line</span></span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
        </div>

        <h3>2. Adjacency List (‡∂Ü‡∑É‡∂±‡∑ä‡∂± ‡∂Ω‡∑ê‡∂∫‡∑í‡∑É‡∑ä‡∂≠‡∑î‡∑Ä)</h3>
        <p>‡∂ë‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ä vertex ‡∂ë‡∂ö ‡∑É‡∂≥‡∑Ñ‡∑è ‡∂ä‡∂ß ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞ vertices ‡∑Ä‡∂Ω list ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂≠‡∂∂‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.</p>

        <div class="code-container">
<span class="code-line"><span class="comment">// Adjacency List ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫‡∑ô‡∂±‡∑ä Graph ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdlib.h&gt;</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// List node ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑É‡∂≥‡∑Ñ‡∑è structure</span></span>
<span class="code-line"><span class="keyword">typedef struct</span> Node {</span>
<span class="code-line">    <span class="keyword">int</span> vertex;                      <span class="comment">// connected vertex</span></span>
<span class="code-line">    <span class="keyword">struct</span> Node* next;               <span class="comment">// ‡∂ä‡∑Ö‡∂ü node ‡∂ë‡∂ö</span></span>
<span class="code-line">} Node;</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Graph structure - adjacency list ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫‡∑ô‡∂±‡∑ä</span></span>
<span class="code-line"><span class="keyword">typedef struct</span> {</span>
<span class="code-line">    <span class="keyword">int</span> vertices;                    <span class="comment">// vertices ‡∂ú‡∂´‡∂±</span></span>
<span class="code-line">    Node** adjLists;                   <span class="comment">// lists array ‡∂ë‡∂ö‡∂ö‡∑ä</span></span>
<span class="code-line">} Graph;</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Node ‡∂ë‡∂ö‡∂ö‡∑ä create ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line">Node* <span class="function">createNode</span>(<span class="keyword">int</span> v) {</span>
<span class="code-line">    Node* newNode = <span class="function">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// memory allocate ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    newNode->vertex = v;                <span class="comment">// vertex value set ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    newNode->next = <span class="keyword">NULL</span>;               <span class="comment">// next pointer NULL ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="keyword">return</span> newNode;                     <span class="comment">// ‡∂±‡∑Ä node ‡∂ë‡∂ö return ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Graph ‡∂ë‡∂ö‡∂ö‡∑ä create ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line">Graph* <span class="function">createGraph</span>(<span class="keyword">int</span> vertices) {</span>
<span class="code-line">    Graph* graph = <span class="function">malloc</span>(<span class="keyword">sizeof</span>(Graph)); <span class="comment">// graph ‡∑É‡∂≥‡∑Ñ‡∑è memory</span></span>
<span class="code-line">    graph->vertices = vertices;          <span class="comment">// vertices ‡∂ú‡∂´‡∂± set ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    </span>
<span class="code-line">    <span class="comment">// adjacency lists array ‡∂ë‡∂ö create ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    graph->adjLists = <span class="function">malloc</span>(vertices * <span class="keyword">sizeof</span>(Node*));</span>
<span class="code-line">    </span>
<span class="code-line">    <span class="comment">// ‡∑É‡∑í‡∂∫‡∂Ω‡∑î lists NULL ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < vertices; i++) {</span>
<span class="code-line">        graph->adjLists[i] = <span class="keyword">NULL</span>;       <span class="comment">// ‡∂ë‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ä list NULL ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    }</span>
<span class="code-line">    </span>
<span class="code-line">    <span class="keyword">return</span> graph;                       <span class="comment">// graph return ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Edge ‡∂ë‡∂ö‡∂ö‡∑ä add ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">addEdge</span>(Graph* graph, <span class="keyword">int</span> src, <span class="keyword">int</span> dest) {</span>
<span class="code-line">    <span class="comment">// src vertex ‡∂ë‡∂ö‡∑ö list ‡∂ë‡∂ö‡∂ß dest add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    Node* newNode = <span class="function">createNode</span>(dest);   <span class="comment">// ‡∂±‡∑Ä node ‡∂ë‡∂ö‡∂ö‡∑ä create ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    newNode->next = graph->adjLists[src]; <span class="comment">// list ‡∂ë‡∂ö‡∑ö ‡∂â‡∑É‡∑ä‡∑É‡∂ª‡∑Ñ‡∂ß add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    graph->adjLists[src] = newNode;      <span class="comment">// head ‡∂ë‡∂ö update ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    </span>
<span class="code-line">    <span class="comment">// Undirected graph ‡∂±‡∂∏‡∑ä dest vertex ‡∂ë‡∂ö‡∑ö list ‡∂ë‡∂ö‡∂ß‡∂≠‡∑ä src add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    newNode = <span class="function">createNode</span>(src);         <span class="comment">// ‡∂±‡∑Ä node ‡∂ë‡∂ö‡∂ö‡∑ä</span></span>
<span class="code-line">    newNode->next = graph->adjLists[dest];</span>
<span class="code-line">    graph->adjLists[dest] = newNode;</span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Graph ‡∂ë‡∂ö print ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">printGraph</span>(Graph* graph) {</span>
<span class="code-line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v < graph->vertices; v++) { <span class="comment">// ‡∂ë‡∂ö‡∑ä ‡∂ë‡∂ö‡∑ä vertex</span></span>
<span class="code-line">        Node* temp = graph->adjLists[v];  <span class="comment">// list ‡∂ë‡∂ö ‡∂ú‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        <span class="function">printf</span>(<span class="string">"\n Vertex %d: "</span>, v);       <span class="comment">// vertex ‡∂ë‡∂ö print ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        <span class="keyword">while</span> (temp) {                      <span class="comment">// list ‡∂ë‡∂ö traverse ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">            <span class="function">printf</span>(<span class="string">"%d -> "</span>, temp->vertex); <span class="comment">// connected vertex print</span></span>
<span class="code-line">            temp = temp->next;             <span class="comment">// ‡∂ä‡∑Ö‡∂ü node ‡∂ë‡∂ö‡∂ß ‡∂∫‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        }</span>
<span class="code-line">        <span class="function">printf</span>(<span class="string">"NULL\n"</span>);                <span class="comment">// list ‡∂ë‡∂ö ‡∂Ö‡∑Ä‡∑É‡∂±‡∑ä</span></span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
        </div>

        <h2>Graph Traversal (‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä ‡∂ú‡∂∏‡∂±‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏)</h2>
        
        <h3>1. Breadth-First Search (BFS)</h3>
        <p>BFS ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä level by level graph ‡∂ë‡∂ö traverse ‡∂ö‡∂ª‡∂∫‡∑í. Queue ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂∫‡∑í.</p>

        <div class="code-container">
<span class="code-line"><span class="comment">// BFS Implementation</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdbool.h&gt;</span></span>
<span class="code-line"><span class="keyword">#define</span> MAX <span class="number">10</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// Simple Queue implementation BFS ‡∑É‡∂≥‡∑Ñ‡∑è</span></span>
<span class="code-line"><span class="keyword">int</span> queue[MAX], front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span>
<span class="code-line"></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">enqueue</span>(<span class="keyword">int</span> vertex) {</span>
<span class="code-line">    <span class="keyword">if</span> (rear == MAX - <span class="number">1</span>) <span class="keyword">return</span>;      <span class="comment">// queue full ‡∂±‡∂∏‡∑ä return</span></span>
<span class="code-line">    <span class="keyword">if</span> (front == <span class="number">-1</span>) front = <span class="number">0</span>;        <span class="comment">// ‡∂¥‡∑Ö‡∂∏‡∑î element ‡∂±‡∂∏‡∑ä front set ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    queue[++rear] = vertex;              <span class="comment">// rear ‡∑Ä‡∑ê‡∂©‡∑í ‡∂ö‡∂ª‡∂Ω‡∑è vertex add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="keyword">int</span> <span class="function">dequeue</span>() {</span>
<span class="code-line">    <span class="keyword">if</span> (front == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;        <span class="comment">// queue empty ‡∂±‡∂∏‡∑ä -1</span></span>
<span class="code-line">    <span class="keyword">int</span> vertex = queue[front];          <span class="comment">// front element ‡∂ú‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="keyword">if</span> (front == rear) {                  <span class="comment">// ‡∂Ö‡∂±‡∑ä‡∂≠‡∑í‡∂∏ element ‡∂±‡∂∏‡∑ä</span></span>
<span class="code-line">        front = rear = <span class="number">-1</span>;             <span class="comment">// queue reset ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    } <span class="keyword">else</span> {</span>
<span class="code-line">        front++;                          <span class="comment">// front ‡∂ë‡∂ö ‡∑Ä‡∑ê‡∂©‡∑í ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    }</span>
<span class="code-line">    <span class="keyword">return</span> vertex;                      <span class="comment">// vertex return ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// BFS Algorithm</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">BFS</span>(Graph* g, <span class="keyword">int</span> startVertex) {</span>
<span class="code-line">    <span class="keyword">bool</span> visited[MAX] = {<span class="keyword">false</span>};      <span class="comment">// visited array ‡∂ë‡∂ö‡∂ö‡∑ä (‡∑É‡∑í‡∂∫‡∂Ω‡∑ä‡∂Ω false)</span></span>
<span class="code-line">    </span>
<span class="code-line">    visited[startVertex] = <span class="keyword">true</span>;        <span class="comment">// start vertex visited ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="function">enqueue</span>(startVertex);               <span class="comment">// queue ‡∂ë‡∂ö‡∂ß add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    </span>
<span class="code-line">    <span class="keyword">while</span> (front != <span class="number">-1</span>) {                 <span class="comment">// queue empty ‡∑Ä‡∑ô‡∂±‡∂ö‡∂∏‡∑ä</span></span>
<span class="code-line">        <span class="keyword">int</span> currentVertex = <span class="function">dequeue</span>();  <span class="comment">// queue ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä vertex ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ú‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        <span class="function">printf</span>(<span class="string">"%d "</span>, currentVertex);    <span class="comment">// vertex ‡∂ë‡∂ö print ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        </span>
<span class="code-line">        <span class="comment">// ‡∂∏‡∑ö vertex ‡∂ë‡∂ö‡∂ß adjacent ‡∑É‡∑í‡∂∫‡∂Ω‡∑î vertices ‡∂∂‡∂Ω‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < g->vertices; i++) {</span>
<span class="code-line">            <span class="comment">// Edge ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂á‡∂≠‡∑í ‡∂±‡∂∏‡∑ä ‡∑É‡∑Ñ visited ‡∂±‡∑ê‡∂≠‡∑í ‡∂±‡∂∏‡∑ä</span></span>
<span class="code-line">            <span class="keyword">if</span> (g->adjMatrix[currentVertex][i] == <span class="number">1</span> && !visited[i]) {</span>
<span class="code-line">                visited[i] = <span class="keyword">true</span>;        <span class="comment">// visited ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">                <span class="function">enqueue</span>(i);                <span class="comment">// queue ‡∂ë‡∂ö‡∂ß add ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">            }</span>
<span class="code-line">        }</span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
        </div>

        <h3>2. Depth-First Search (DFS)</h3>
        <p>DFS ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä depth ‡∂Ö‡∂±‡∑î‡∑Ä graph ‡∂ë‡∂ö traverse ‡∂ö‡∂ª‡∂∫‡∑í. Recursion ‡∑Ñ‡∑ù Stack ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂∫‡∑í.</p>

        <div class="code-container">
<span class="code-line"><span class="comment">// DFS Implementation (Recursive)</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="code-line"><span class="keyword">#include</span> <span class="string">&lt;stdbool.h&gt;</span></span>
<span class="code-line"><span class="keyword">#define</span> MAX <span class="number">10</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// DFS helper function (Recursive)</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">DFSUtil</span>(Graph* g, <span class="keyword">int</span> vertex, <span class="keyword">bool</span> visited[]) {</span>
<span class="code-line">    visited[vertex] = <span class="keyword">true</span>;             <span class="comment">// ‡∂∏‡∑ö vertex ‡∂ë‡∂ö visited ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="function">printf</span>(<span class="string">"%d "</span>, vertex);               <span class="comment">// vertex ‡∂ë‡∂ö print ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    </span>
<span class="code-line">    <span class="comment">// ‡∂∏‡∑ö vertex ‡∂ë‡∂ö‡∂ß adjacent ‡∑É‡∑í‡∂∫‡∂Ω‡∑î vertices ‡∂∂‡∂Ω‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < g->vertices; i++) {</span>
<span class="code-line">        <span class="comment">// Edge ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂á‡∂≠‡∑í ‡∂±‡∂∏‡∑ä ‡∑É‡∑Ñ visited ‡∂±‡∑ê‡∂≠‡∑í ‡∂±‡∂∏‡∑ä</span></span>
<span class="code-line">        <span class="keyword">if</span> (g->adjMatrix[vertex][i] == <span class="number">1</span> && !visited[i]) {</span>
<span class="code-line">            <span class="function">DFSUtil</span>(g, i, visited);    <span class="comment">// recursively DFS call ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">        }</span>
<span class="code-line">    }</span>
<span class="code-line">}</span>
<span class="code-line"></span>
<span class="code-line"><span class="comment">// DFS main function</span></span>
<span class="code-line"><span class="keyword">void</span> <span class="function">DFS</span>(Graph* g, <span class="keyword">int</span> startVertex) {</span>
<span class="code-line">    <span class="keyword">bool</span> visited[MAX] = {<span class="keyword">false</span>};      <span class="comment">// visited array ‡∂ë‡∂ö‡∂ö‡∑ä initialize ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">    <span class="function">DFSUtil</span>(g, startVertex, visited); <span class="comment">// DFS helper call ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</span></span>
<span class="code-line">}</span>
        </div>

        <h2>Time Complexity Comparison</h2>
        <table class="table table-bordered complexity-table">
            <thead>
                <tr>
                    <th>Operation</th>
                    <th>Adjacency Matrix</th>
                    <th>Adjacency List</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Add Vertex</td>
                    <td>O(V¬≤)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Add Edge</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Remove Vertex</td>
                    <td>O(V¬≤)</td>
                    <td>O(V + E)</td>
                </tr>
                <tr>
                    <td>Remove Edge</td>
                    <td>O(1)</td>
                    <td>O(E)</td>
                </tr>
                <tr>
                    <td>Check if Edge Exists</td>
                    <td>O(1)</td>
                    <td>O(V)</td>
                </tr>
                <tr>
                    <td>Space Complexity</td>
                    <td>O(V¬≤)</td>
                    <td>O(V + E)</td>
                </tr>
            </tbody>
        </table>

        <h2>‡∂ú‡∑ä‚Äç‡∂ª‡∑ê‡∑Ü‡∑ä ‡∑Ä‡∂Ω ‡∂∫‡∑ô‡∂Ø‡∑ì‡∂∏‡∑ä</h2>
        <div class="highlight-box">
            <ul>
                <li><strong>‡∑É‡∂∏‡∑è‡∂¢ ‡∂¢‡∑è‡∂Ω:</strong> Facebook, Twitter ‡∑Ä‡∑ê‡∂±‡∑í networks ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß</li>
                <li><strong>‡∂∏‡∑è‡∂ª‡∑ä‡∂ú ‡∂¢‡∑è‡∂Ω:</strong> GPS ‡∑É‡∑Ñ navigation systems ‡∑É‡∂≥‡∑Ñ‡∑è</li>
                <li><strong>Computer Networks:</strong> Network topology ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß</li>
                <li><strong>Dependency Graphs:</strong> Software dependencies track ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß</li>
                <li><strong>Recommendation Systems:</strong> ‡∂∑‡∑è‡∂´‡∑ä‡∂© ‡∑Ñ‡∑ù ‡∂∏‡∑í‡∂≠‡∑î‡∂ª‡∂±‡∑ä recommend ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß</li>
            </ul>
        </div>

        <h2>‡∑É‡∑è‡∂ª‡∑è‡∂Ç‡∑Å‡∂∫</h2>
        <p>Graphs ‡∂∫‡∂±‡∑î ‡∂∂‡∑Ñ‡∑î‡∂Ω‡∑ä‚Äç‡∂∫ ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞‡∂≠‡∑è ‡∂±‡∑í‡∂ª‡∑ñ‡∂¥‡∂´‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∑ö ‡∂¥‡∑ä‚Äç‡∂ª‡∂∂‡∂Ω ‡∂Ø‡∂≠‡∑ä‡∂≠ ‡∑Ä‡∑ä‚Äç‡∂∫‡∑î‡∑Ñ‡∂∫‡∂ö‡∑í. Adjacency Matrix ‡∑Ñ‡∑ù Adjacency List ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∂∫‡∑ô‡∂±‡∑ä implement ‡∂ö‡∑Ö ‡∑Ñ‡∑ê‡∂ö. BFS ‡∑É‡∑Ñ DFS ‡∂∏‡∂ú‡∑í‡∂±‡∑ä graph traversal ‡∂ö‡∑Ö ‡∑Ñ‡∑ê‡∂ö.</p>

        <button class="btn back-btn" onclick="location.href='../index.html'">‚Üê ‡∂∏‡∑î‡∂Ω‡∑ä ‡∂¥‡∑í‡∂ß‡∑î‡∑Ä‡∂ß</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>